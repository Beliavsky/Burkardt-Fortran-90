- **allocatable_array_test**: demonstrates how a main program can declare an allocatable array, which is then passed to a subroutine which allocates it, initializes it, and returns it to the calling program for further use.
- 
- **analemma**: evaluates the equation of time, a formula for the difference between the uniform 24 hour day and the actual position of the sun, creating data files that can be plotted with gnuplot(), based on code by Brian Tung.
- 
- **annulus_monte_carlo**: uses the Monte Carlo method to estimate the integral of a function over the interior of a circular annulus in 2D.
- 
- **apportionment**: demonstrates some of the methods used or proposed for fairly assigning seats in the House of Representatives to each state;
- 
- **args**: reports the command line arguments of a Fortran90 code;
- 
- **arpack**: numerical software library for solving large scale eigenvalue problems. The package is designed to compute a few eigenvalues and corresponding eigenvectors of large sparse or structured matrices, using the Implicitly Restarted Arnoldi Method (IRAM) or, in the case of symmetric matrices, the corresponding variant of the Lanczos algorithm. It is used by many popular numerical computing environments such as SciPy, Mathematica, GNU Octave and MATLAB to provide this functionality.
- 
- **asa005**: evaluates the Cumulative Density Function (CDF) of the noncentral T Probability Density Function (PDF), by BE Cooper. This is a version of Applied Statistics Algorithm 5;
- 
- **asa006**: computes the Cholesky factorization of a symmetric positive definite (SPD) matrix, by Michael Healy. This is a version of Applied Statistics Algorithm 6;
- 
- **asa007**: computes the inverse of a symmetric positive definite (SPD) matrix, by Michael Healy. This is a version of Applied Statistics Algorithm 7.
- 
- **asa032**: evaluates the incomplete Gamma function, by G Bhattacharjee. This is a version of Applied Statistics Algorithm 32.
- 
- **asa047**: minimizes a scalar function of several variables using the Nelder-Mead algorithm, by R ONeill. This is a version of Applied Statistics Algorithm 47.
- 
- **asa053**: produces sample matrices from the Wishart distribution, by William Smith and Ronald Hocking. This is a version of Applied Statistics Algorithm 53.
- 
- **asa058**: implements the K-means data clustering algorithm, by David Sparks. This is a version of Applied Statistics Algorithm 58.
- 
- **asa063**: evaluates the incomplete Beta function, by KL Majumder and G Bhattacharjee. This is a version of Applied Statistics Algorithm 63.
- 
- **asa066**: evaluates the Cumulative Density Function (CDF) of the normal probability distribution, by David Hill. This is a version of Applied Statistics Algorithm 66.
- 
- **asa076**: evaluates the Owen T function, needed to compute the Cumulative Density Function (CDF) of the noncentral T distribution, by Young and Minder. This is a version of Applied Statistics Algorithm 76.
- 
- **asa082**: computes the determinant of an orthogonal matrix; this is a version of Applied Statistics Algorithm 82, by J C Gower.
- 
- **asa091**: evaluates the percentage points of the Chi-Squared distribution, by Best and Roberts. This is a version of Applied Statistics Algorithm 91.
- 
- **asa103**: evaluates the digamma or psi function, by Jose Bernardo. This is a version of Applied Statistics Algorithm 103.
- 
- **asa109**: inverts the incomplete Beta function, by Cran, Martin and Thomas. This is a version of Applied Statistics Algorithm 109.
- 
- **asa111**: evaluates the percentage points of the normal distribution, by Beasley and Springer. This is a version of Applied Statistics Algorithm 111.
- 
- **asa113**: implements a clustering algorithm using transfers and swaps, by Banfield and Bassill. This is a version of Applied Statistics Algorithm 113.
- 
- **asa121**: evaluates the trigamma function, by BE Schneider. This is a version of Applied Statistics Algorithm 121.
- 
- **asa136**: implements a clustering algorithm, by Hartigan and Wong. This is a version of Applied Statistics Algorithm 136.
- 
- **asa144**: randomly generates an RxC contingency table, by James Boyett. This is a version of Applied Statistics Algorithm 144.
- 
- **asa147**: evaluates the incomplete Gamma function, by Chi Leung Lau. This is a version of Applied Statistics Algorithm 147.
- 
- **asa152**: evaluates the Probability Density Function (PDF) and Cumulative Density Function (CDF) associated with the hypergeometric distribution, by Richard Lund; this is a version of Applied Statistics Algorithm 152.
- 
- **asa159**: randomly generates an RxC contingency table, by Michael Patefield; This is a version of Applied Statistics Algorithm 159.
- 
- **asa172**: generates all M-dimensional indices in a given range, simulating the behavior of an arbitrary number of nested loops, by OFlaherty and MacKenzie. This is a version of Applied Statistics Algorithm 172.
- 
- **asa183**: implements a random number generator (RNG), by Wichman and Hill. This is a version of Applied Statistics Algorithm 183.
- 
- **asa189**: estimates the parameters of a beta binomial distribution based on a sample of values generated by the distribution, by D Smith; this is a version of Applied Statistics Algorithm 189;
- 
- **asa205**: generates all the contingency tables corresponding to a given set of row and column sums. This is a version of Applied Statistics Algorithm 205.
- 
- **asa226**: evaluates the Cumulative Density Function (CDF) of the noncentral Beta distribution, by Russell Lenth. This is a version of Applied Statistics Algorithm 226.
- 
- **asa239**: evaluates the incomplete Gamma function, by Shea. This is a version of Applied Statistics Algorithm 239.
- 
- **asa241**: evaluates the percentage points of the normal distribution, by Michael Wichura. This is a version of Applied Statistics Algorithm 241.
- 
- **asa243**: evaluates the Cumulative Density Function (CDF) of the noncentral T distribution, by Russell Lenth; this is a version of Applied Statistics Algorithm 243.
- 
- **asa245**: evaluates the logarithm of the Gamma function, by Allan Mcleod; this is a version of Applied Statistics Algorithm 245.
- 
- **asa266**: evaluates various properties of the Dirichlet Probability Density Function (PDF); this is a version of Applied Statistics Algorithm 266;
- 
- **asa299**: computes the lattice points in an M-dimensional simplex, by Chasalow and Brand; this is a version of Applied Statistics Algorithm 299;
- 
- **asa310**: computes the Cumulative Density Function (CDF) of the noncentral Beta distribution, by Chattamvelli and Shanmugam; this is a version of Applied Statistics Algorithm 310.
- 
- **asa314**: computes the inverse of a matrix whose elements are subject to modulo arithmetic, by Roger Payne. This is a version of Applied Statistics Algorithm 314;
- 
- **atbash**: applies the Atbash substitution cipher to a string of text.
- 
- **backtrack_binary_rc**: carries out a backtrack search for binary decisions, using reverse communication (RC).
- 
- **backward_euler**: solves one or more ordinary differential equations (ODE) using the (implicit) backward Euler method, using a version of fsolve() for the implicit equation.
- 
- **ball_grid**: computes grid points inside a 3D ball.
- 
- **ball_integrals**: returns the exact value of the integral of any monomial over the interior of the unit ball in 3D.
- 
- **ball_monte_carlo**: applies a Monte Carlo method to estimate integrals of a function over the interior of the unit ball in 3D;
- 
- **band_qr**: computes the QR factorization of a banded matrix, and solves related linear systems, by Alfredo Remon, Enrique Quintana-Orti, Gregorio Quintana-Orti.
- 
- **barycentric_interp_1d**: defines and evaluates the barycentric Lagrange polynomial p(x) which interpolates data, so that p(x(i)) = y(i). The barycentric approach means that very high degree polynomials can safely be used.
- 
- **bdf2**: solves one or more ordinary differential equations (ODE) using the (implicit) backward difference formula of order 2 (BDF2), using fsolve() to solve the implicit equation.
- 
- **bdmlib**: estimates the weights in a Dirichlet mixture based on sample data;
- 
- **bellman_ford**: implements the Bellman-Ford algorithm for finding the shortest distance from a given node to all other nodes in a directed graph whose edges have been assigned real-valued lengths.
- 
- **bernstein_polynomial**: evaluates the Bernstein polynomials;
- 
- **besselj**: evaluates Bessel J functions of noninteger order;
- 
- **beta_nc**: evaluates the cumulative density function (CDF) of the noncentral Beta distribution;
- 
- **bezier_surface**: reads, writes, prints and manipulates the data that defines a Bezier surface;
- 
- **biharmonic_exact**: evaluates exact solutions w(x,y) to the biharmonic equation del^2 w = 0 or wxxxx + 2 wxxyy + wyyyy = 0
- 
- **bins**: sorts data into order, or lumps it into bins, or selects an item of particular rank, or finds the unique elements in a list.
- 
- **bisection**: applies the bisection method to seek a root of f(x) over a change-of-sign interval a <= x <= b.
- 
- **bisection_integer**: seeks an integer solution to the equation F(X)=0, using bisection within a user-supplied change of sign interval [A,B].
- 
- **bisection_rc**: seeks a solution to the equation F(X)=0 using bisection within a user-supplied change of sign interval [A,B]. The procedure is written using reverse communication (RC).
- 
- **bivar**: interpolates scattered bivariate data. This is a version of ACM TOMS algorithm 526, by Hiroshi Akima.
- 
- **black_scholes**: implements some simple approaches to the Black-Scholes option valuation theory, creating graphics files for processing by gnuplot(), by Desmond Higham.
- 
- **blend**: carries out 1D/2D/3D blending interpolation;
- 
- **box_behnken**: computes a Box-Behnken design, that is, arguments to sample the behavior of a function of multiple parameters;
- 
- **brownian_motion_simulation**: simulates Brownian motion in an M-dimensional region, creating graphics files for processing by gnuplot().
- 
- **bump**: solves a 2D steady incompressible flow problem set in a channel with a small bump.
- 
- **burgers_exact**: evaluates exact solutions of the time-dependent 1D viscous Burgers equation.
- 
- **bvec**: demonstrates how signed integers can be stored as binary vectors, and arithmetic can be performed on them.
- 
- **bvls**: applies linear least squares (LLS) methods to solve a system for which lower and upper constraints may have been placed on every variable, by Charles Lawson and Richard Hanson.
- 
- **c_comment**: reads an ASCII text file, and writes a copy, in which C++ style comments have been replaced by equivalent C-style comments.
- 
- **c8lib**: implements certain elementary functions for double precision complex (C8) variables;
- 
- **c8poly**: operates on complex polynomials.
- 
- **caesar**: applies a Caesar Shift Cipher to a string of text.
- 
- **calendar_nyt**: shows the correspondence between dates and the New York Times volume and issue number;
- 
- **calpak**: computes various simple calendrical quantities. It can work with various calendars including Egyptian, English, French Revolutionary, Gregorian, Julian, and Julian Ephemeris Date. It can convert a date from one calendar to another. It can return the day of the week for a given date. It can convert from day-number/year to day/month/year format. It can calculate the time difference between two dates.
- 
- **candy_count**: counts the types of candy in a rectangular container, which might be a vector, matrix, or 3D box. The candy is assumed to have C possible types, and to have been entered into the container in a cycle that begins with type 1. While the vector case is easy, it is already difficult to come up with a general formula for the MxN matrix case.
- 
- **cauchy_principal_value**: uses Gauss-Legendre quadrature to estimate the Cauchy Principal Value (CPV) of certain singular integrals.
- 
- **ccn_rule**: defines a Clenshaw Curtis Nested (CCN) quadrature rule.
- 
- **ccs_io**: reads and writes sparse linear systems stored in the Compressed Column Storage (CCS) format.
- 
- **ccs_to_st**: converts a sparse matrix from compressed column storage (CCS) to sparse triplet (ST) format.
- 
- **cdflib**: evaluates the cumulative density function (CDF), inverse CDF, and certain other inverse functions, for distributions including beta, binomial, chi-square, noncentral chi-square, F, noncentral F, gamma, negative binomial, normal, Poisson, and students T, by Barry Brown, James Lovato, Kathy Russell.
- 
- **cell**: defines a cell array, a generalization of an array which compactly stores and retrieves vector or matrix data of varying size, such as the rows of a triangular matrix.
- 
- **cg**: implements a simple version of the conjugate gradient (CG) method for solving a system of linear equations of the form A*x=b, suitable for situations in which the matrix A is positive definite, only real, positive eigenvalues and symmetric.
- 
- **cg_rc**: implements the conjugate gradient (CG) method for solving a positive definite sparse linear system A*x=b, using reverse communication (RC).
- 
- **change_dynamic**: uses dynamic programming to solve the change making problem, in which a given sum is to be formed using coins of various denominations.
- 
- **channel**: computes the time-independent flow of a viscous incompressible fluid in a 2D channel.
- 
- **chebyshev**: computes the Chebyshev interpolant/approximant to a given function over an interval.
- 
- **chebyshev_interp_1d**: determines the combination of Chebyshev polynomials which interpolates data, so that p(x(i)) = y(i).
- 
- **chebyshev_polynomial**: considers the Chebyshev polynomials T(i,x), U(i,x), V(i,x) and W(i,x). Functions are provided to evaluate the polynomials, determine their zeros, produce their polynomial coefficients, produce related quadrature rules, project other functions onto these polynomial bases, and integrate double and triple products of the polynomials.
- 
- **chebyshev_series**: evaluates a Chebyshev series approximating a function f(x), while efficiently computing one, two or three derivatives of the series, which approximate f'(x), f''(x), and f'''(x), by Manfred Zimmer.
- 
- **chrpak**: manipulates characters and strings;
- 
- **circle_arc_grid**: computes a grid of points over the length of a circle or circular arc in 2D.
- 
- **circle_integrals**: returns the exact value of the integral of any monomial over the circumference of the unit circle in 2D.
- 
- **circle_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function along the circumference of the unit circle in 2D;
- 
- **circle_packing**: performs a circle-packing test on the spacing for points;
- 
- **circle_segment**: carries out computations associated with a circle segment, including height, angle, area, centroid, sampling, and quadrature, creating some graphics images using gnuplot().
- 
- **clausen**: evaluates a Chebyshev interpolant to the Clausen function Cl2(x).
- 
- **clenshaw_curtis_grid**: sets up a Clenshaw Curtis quadrature rule in multiple dimensions;
- 
- **closest_pair_brute**: uses brute force to solve a 2D version of the closest pair problem, which identifies the closest pair of points in a given collection.
- 
- **closest_point_brute**: uses brute force to find the nearest of a set of N points in D dimensions to a given test point. This is sometimes called a nearest neighbor calculation.
- 
- **cluster_energy**: groups data into a given number of clusters to minimize the energy.
- 
- **cnf_io**: reads or writes DIMACS Conjunctive Normal Form (CNF) files defining satisfiability problems in terms of a boolean formula.
- 
- **codepack**: determine if two graphs are isomorphic.
- 
- **collatz_recursive**: demonstrates recursive programming by considering the simple Collatz 3n+1 problem.
- 
- **color_digraph_adj**: carries out operations on color digraphs, a directed graph in which each node has been assigned a color. That information is stored in an adjacency matrix in which the diagonal elements record colors. Operations include counting the colors, computing in- and out-degrees, computing the in- and out-degree sequences, counting the edges, printing the adjacency matrix, generating fixed and random examples.
- 
- **color_graph_adj**: carries out operations on color graphs, an undirected graph in which each node has been assigned a color. That information is stored in an adjacency matrix in which the diagonal elements record colors. Operations include counting the colors, computing degrees, computing the degree sequences, counting the edges, printing the adjacency matrix, generating fixed and random examples.
- 
- **colored_noise**: generates samples of noise obeying a 1/f^alpha power law.
- 
- **colors**: converts between various formats for describing colors;
- 
- **combo**: ranks, unranks, enumerates, lists and randomly selects balanced sequences, cycles, graphs, Gray codes, subsets, partitions, permutations, restricted growth functions, Pruefer codes and trees.
- 
- **communicator_mpi**: creates new communicators involving a subset of initial set of MPI processes in the default communicator MPI_COMM_WORLD.
- 
- **companion_matrix**: computes the companion matrix for a polynomial. The polynomial may be represented in the standard monomial basis, or as a sum of Chebyshev, Gegenbauer, Hermite, Laguerre, or Lagrange basis polynomials. All the roots of the polynomial can be determined as the eigenvalues of the corresponding companion matrix.
- 
- **compass_search**: seeks the minimizer of a scalar function of several variables using compass search, a direct search algorithm that does not use derivatives.
- 
- **components**: organizes contiguous cells into labeled clusters, for a 1D, 2D, or 3D array. This code has uses in image analysis and percolation simulation.
- 
- **condition**: implements methods of computing or estimating the condition number of a matrix.
- 
- **continued_fraction**: deals with simple and generalized continued fractions.
- 
- **cordic**: computes a few special functions using the CORDIC algorithm.
- 
- **correlation**: contains examples of statistical correlation functions.
- 
- **cosine_transform**: demonstrates some simple properties of the discrete cosine transform (DCT).
- 
- **crystal_coordinates**: generates the coordinates of a set of 4 * NX * NY * NZ points in a rectangular block of NX * NY * NZ cells, with face-centered cubic (FCC) symmetry.
- 
- **csv_io**: reads and writes files that use the Comma Separated Value (CSV) format.
- 
- **cube_exactness**: computes the polynomial exactness of quadrature rules over the interior of a cube in 3D.
- 
- **cube_grid**: computes a grid of points over the interior of a cube in 3D.
- 
- **cube_integrals**: returns the exact value of the integral of any monomial over the interior of the unit cube in 3D.
- 
- **cube_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function over the interior of the unit cube in 3D.
- 
- **cuda_loop**: shows how, in a CUDA program running on a Graphics Processing Unit (GPU), the choice of block and thread factors determines the allocation of tasks to processors.
- 
- **cvt**: computes elements of a Centroidal Voronoi Tessellation (CVT).
- 
- **cvt_basis**: uses discrete Centroidal Voronoi Tessellation (CVT) techniques to produce a small set of basis vectors that are good cluster centers for a large set of data vectors;
- 
- **cvt_basis_flow**: extracts dominant solution modes from solutions of a flow problem governed by the Navier Stokes Equations (NSE) using Centroidal Voronoi Tessellation (CVT) methods.
- 
- **cvt_box**: calculates a Centroidal Voronoi Tessellation (CVT) constrained to a box region, with points projected to the boundary;
- 
- **cvtp**: creates a Centroidal Voronoi Tessellation on a Periodic region (CVTP).
- 
- **cvt_triangulation**: applies Centroidal Voronoi Tessellation (CVT) techniques to the test_triangulation() set;
- 
- **cyclic_reduction**: solves a tridiagonal linear system using cyclic reduction.
- 
- **diaphony**: reads a file of N points in M dimensions and computes its diaphony, a measure of point dispersion.
- 
- **differ**: is given function values at equally spaced locations, and the order of a derivative, and uses the finite difference method (FDM) to compute a linear combination of these function values which approximated that derivative.
- 
- **digraph_adj**: carries out operations on digraphs, a directed graph. Information is stored in an adjacency matrix. Operations include computing in- and out-degrees, computing the in- and out-degree sequences, counting the edges, printing the adjacency matrix, generating fixed and random examples.
- 
- **digraph_arc**: carries out operations on digraphs, a directed graph. Information is stored in an arc list, pairs of nodes forming edges. Operations include computing in- and out-degrees, computing the in- and out-degree sequences, counting the edges, printing the arc list, generating fixed and random examples.
- 
- **dijkstra**: implements a simple version of the Dijkstra minimum distance algorithm for graphs.
- 
- **discrete_pdf_sample_2d**: demonstrates how to construct a Probability Density Function (PDF) from a table of sample data, and then to use that PDF to create new samples.
- 
- **disk_grid**: computes grid points within the interior of a disk of user specified radius and center in 2D, using gnuplot() to create an image of the grid.
- 
- **disk_monte_carlo**: applies a Monte Carlo method to estimate integrals of a function over the interior of the general disk in 2D;
- 
- **disk01_integrals**: returns the exact value of the integral of any monomial over the interior of the unit disk in 2D.
- 
- **disk01_monte_carlo**: applies a Monte Carlo method to estimate integrals of a function over the interior of the unit disk in 2D;
- 
- **disk01_positive_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function over the interior of the unit positive disk in 2D;
- 
- **distance_to_position**: estimates the positions of cities based on a city-to-city distance table.
- 
- **divdif**: creates, prints and manipulates divided difference polynomials from a table of values (x,f(x)). The code can compute the coefficients of the Newton and power sum forms of the interpolating polynomial. It can compute the derivative or antiderivate polynomial. It can compute the form of the Lagrange basis polynomials. It can compute the points and weights for Newton Cotes quadrature rules. It can compute the weights for a Lagrange interpolation scheme.
- 
- **doomsday**: is given the year, month and day of a date, and uses John Conway's doomsday algorithm to determine the corresponding day of the week.
- 
- **dqed**: solves (square) systems of nonlinear equations, or minimizes the residual in a set of nonlinear equations, using least squares, by Richard Hanson and Fred Krogh.
- 
- **dream**: implements the DREAM algorithm for accelerating Markov Chain Monte Carlo (MCMC) convergence using differential evolution, using five user functions to define the problem, by Guannan Zhang.
- 
- **duel_simulation**: simulates N repetitions of a duel between two players, each of whom has a known firing accuracy.
- 
- **dutch**: carries out tasks in computational geometry.
- 
- **edge**: defines some test functions in 1D, 2D and 3D for the detection of edges or discontinuities. It uses gnuplot() to display the jumps in curves and surfaces.
- 
- **eigs**: computes the eigenvalues and eigenvectors of a matrix.
- 
- **eispack**: carries out eigenvalue computations. It includes a function to compute the singular value decomposition (SVD) of a rectangular matrix. superseded by lapack();
- 
- **ellipse**: carries out geometric calculations for ellipses and ellipsoids, including area, distance to a point, eccentricity, perimeter, points along the perimeter, random sampling, conversion between standard and quadratic forms.
- 
- **ellipse_grid**: computes grid points over the interior of an ellipse in 2D.
- 
- **ellipse_monte_carlo**: uses the Monte Carlo method to estimate the value of integrals over the interior of an ellipse in 2D.
- 
- **ellipsoid**: carries out geometric calculations for ellipsoids, including area, random sampling, conversion between standard and quadratic forms.
- 
- **ellipsoid_grid**: computes a grid of points over the interior of an ellipsoid in 3D.
- 
- **ellipsoid_monte_carlo**: uses the Monte Carlo method to estimate the value of integrals over the interior of an ellipsoid in M dimensions.
- 
- **elliptic_integral**: evaluates complete elliptic integrals of first, second and third kind, using the Carlson elliptic integral functions.
- 
- **etdrk4**: uses the ETD RK4 method to solve systems of stiff ordinary differential equations (ODE), by Aly-Khan Kassam, Lloyd Trefethen.
- 
- **euler**: solves one or more ordinary differential equations (ODE) using the forward Euler method.
- 
- **exactness**: investigates the exactness of quadrature rules that estimate the integral of a function with a density, such as 1, exp(-x) or exp(-x^2), over an interval such as [-1,+1], [0,+oo) or (-oo,+oo).
- 
- **extract**: pulls a copy of a Fortran block data, function, module, program or subroutine from a big file, and saves the copy in a little file.
- 
- **f90_combinatorics**: considers a variety of problems in combinatorics involving counting, combinations, permutations, and so on.
- 
- **f90_exact**: evaluates exact solutions to a few selected examples of ordinary differential equations (ODE) and partial differential equations (PDE).
- 
- **f90_monte_carlo**: uses Monte Carlo sampling to estimate areas and integrals.
- 
- **f90_ode_solver**: solves one or more differential equations (ODE) using a method of a particular order, either explicit or implicit. Some methods require a nonlinear equation solver. Some methods used a fixed stepsize, while others adapt the stepsize based on an error estimate.
- 
- **f90_rule**: computes a quadrature rule which estimates the integral of a function f(x), which might be defined over a one dimensional region (a line) or more complex shapes such as a circle, a triangle, a quadrilateral, a polygon, or a higher dimensional region, and which might include an associated weight function w(x).
- 
- **f90_simulation**: uses simulation to study card games, contests, and other processes which have a random element. Usually, the purpose is to try to predict the average behavior of the system over many trials.
- 
- **f90split**: reads a Fortran file and creates individual files for every blockdata, function, module, program, or subroutine in the file.
- 
- **fair_dice_simulation**: simulates N games where two fair dice are thrown and summed, creating graphics files for processing by gnuplot().
- 
- **fd_predator_prey**: solves a pair of predator prey ordinary differential equations (ODE) using the finite difference method (FDM), and plots the data with gnuplot().
- 
- **fd1d_advection_diffusion_steady**: applies the finite difference method (FDM) to solve the steady advection diffusion equation v*ux-k*uxx=0 in one spatial dimension, with constant velocity v and diffusivity k, writing graphics files for processing by gnuplot().
- 
- **fd1d_advection_ftcs**: applies the finite difference method (FDM) to solve the time-dependent advection equation ut = - c * ux in one spatial dimension, with a constant velocity, using the forward time centered space (FTCS) method, writing graphics files for processing by gnuplot().
- 
- **fd1d_advection_lax**: applies the finite difference method (FDM) to solve the time-dependent advection equation ut = - c * ux in one spatial dimension, with a constant velocity, using the Lax method to approximate the time derivative, writing graphics files for processing by gnuplot().
- 
- **fd1d_advection_lax_wendroff**: applies the finite difference method (FDM) to solve the time-dependent advection equation ut = - c * ux in one spatial dimension, with a constant velocity, using the Lax-Wendroff method to approximate the time derivative, writing graphics files for processing by gnuplot().
- 
- **fd1d_burgers_lax**: applies the finite difference method (FDM) and the Lax Wendroff method to solve the non-viscous time-dependent Burgers equation in one spatial dimension.
- 
- **fd1d_burgers_leap**: applies the finite difference method (FDM) and the leapfrog approach to solve the non-viscous time-dependent Burgers equation in one spatial dimension.
- 
- **fd1d_bvp**: applies the finite difference method (FDM) to a two point boundary value problem (BVP) in one spatial dimension.
- 
- **fd1d_heat_explicit**: implements a finite difference method (FDM), explicit in time, of the time dependent 1D heat equation;
- 
- **fd1d_heat_implicit**: implements a finite difference method (FDM), implicit in time, of the time dependent 1D heat equation;
- 
- **fd1d_heat_steady**: implements a finite difference method (FDM) for the steady time-independent 1D heat equation;
- 
- **fd1d_predator_prey**: implements the finite difference method (FDM) for a predator-prey system with time and 1D spatial dependence, by Marcus Garvie.
- 
- **fd1d_wave**: applies the finite difference method (FDM) to solve the time-dependent wave equation utt = c * uxx in one spatial dimension.
- 
- **fd2d_heat_steady**: implements a finite difference method (FDM) for the steady time-independent 2D heat equation;
- 
- **fd2d_predator_prey**: implements the finite difference method (FDM) for a 2D predator-prey system, by Marcus Garvie.
- 
- **fem_basis**: defines and evaluates basis functions associated with the finite element method (FEM) for any degree in an M-dimensional simplex: 1D interval, 2D triangle, 3D tetrahedron, and higher dimensional generalizations.)
- 
- **fem_io**: reads or writes FEM files, which describe the nodes, elements, and function values associated with a finite element method (FEM) model;
- 
- **fem_to_gmsh**: reads a pair of FEM files defining node coordinates and elements, of a 1D, 2D or 3D mesh, namely a file of node coordinates and a file of elements defined by node indices, and creates a gmsh() mesh file.
- 
- **fem_to_medit**: reads FEM files defining the node coordinates, boundary nodes, and elements of a finite element mesh, and rewrites the data as a medit() MESH file.
- 
- **fem_to_tec**: converts FEM models into tecplot ASCII files.
- 
- **fem_to_triangle**: reads FEM files defining a 2D mesh of triangles, namely a file of node coordinates and a file of elements defined by node indices, and creates a corresponding pair of node and element files for Jonathan Shewchuk's triangle() program
- 
- fem_to_xml, reads a pair of FEM files defining node coordinates and elements, of a 1D, 2D or 3D mesh, namely a file of node coordinates and a file of elements defined by node indices, and creates a corresponding XML file for input to dolfin() or fenics().
- 
- **fem1d**: applies the finite element method (FEM), using piecewise linear basis functions, to a linear two point boundary value problem (BVP) in 1D;
- 
- **fem1d_adaptive**: uses an adaptive mesh when applying the finite element method (FEM), with piecewise linear basis functions, to a linear two point boundary value problem (BVP) in 1D;
- 
- **fem1d_bvp_linear**: applies the finite element method (FEM), with piecewise linear elements, to a two point boundary value problem (BVP) in one spatial dimension, and compares the computed and exact solutions with the L2 and seminorm errors.
- 
- **fem1d_bvp_quadratic**: applies the finite element method (FEM), with piecewise quadratic elements, to a two point boundary value problem (BVP) in one spatial dimension, and compares the computed and exact solutions with the L2 and seminorm errors.
- 
- **fem1d_heat_steady**: implements the finite element method (FEM) for the steady time-independent 1D heat equation;
- 
- **fem1d_lagrange**: sets up the matrices and vectors associated with the finite element method (FEM) solution of a boundary value problem (BVP) -u''+u=f(x), using Lagrange basis polynomials.
- 
- **fem1d_nonlinear**: applies the finite element method (FEM), with piecewise linear basis functions, to a nonlinear two point boundary value problem (BVP) in 1D;
- 
- **fem1d_pack**: contains utilities for 1D finite element method (FEM) calculations.
- 
- **fem1d_pmethod**: applies the p-method version of the finite element method (FEM) to a linear two point boundary value problem (BVP) in 1D;
- 
- **fem1d_project**: projects data into a finite element space, including the least squares approximation of data, or the projection of a finite element solution from one mesh to another.
- 
- **fem1d_sample**: samples a scalar or vector finite element function of one variable, defined by FEM files, returning interpolated values at the sample points.
- 
- **fem2d_bvp_linear**: applies the finite element method (FEM), with piecewise linear elements, to a 2D boundary value problem (BVP) in a rectangle, and compares the computed and exact solutions with the L2 and seminorm errors.
- 
- **fem2d_bvp_quadratic**: applies the finite element method (FEM), with piecewise quadratic elements, to a 2D boundary value problem (BVP) in a rectangle, and compares the computed and exact solutions with the L2 and seminorm errors.
- 
- **fem2d_bvp_serene**: applies the finite element method (FEM), with serendipity elements, to a 2D boundary value problem (BVP) in a rectangle, and compares the computed and exact solutions with the L2 and seminorm errors.
- 
- **fem2d_heat**: uses the finite element method (FEM) and the backward Euler method to solve the time-dependent heat equation on an arbitrary triangulated region in 2D. The user supplies some information in some problem-dependent subroutines.
- 
- **fem2d_heat_rectangle**: implements the finite element method (FEM) for the time dependent heat equation on a triangulated square in 2D;
- 
- **fem2d_pack**: implements simple 2D finite element method (FEM) calculations;
- 
- **fem2d_poisson_rectangle**: solves the 2D Poisson equation on a rectangle, using the finite element method (FEM), and piecewise quadratic triangular elements.
- 
- **fem2d_poisson_rectangle_linear**: solves the 2D Poisson equation on a rectangle, using the finite element method (FEM), and piecewise linear triangular elements.
- 
- **fem2d_sample**: samples at arbitray points a finite element function, defined by FEM files, three text files describing the nodes, triangles, and coefficients.
- 
- **fem3d_pack**: contains utilities for 3D finite element method (FEM) calculations.
- 
- **fem3d_sample**: evaluates a finite element function defined on a 3D tetrahedral mesh.
- 
- **fftpack5**: computes Fast Fourier Transforms (FFTs), by Paul Swarztrauber and Dick Valent;
- 
- **fftpack51**: computes Fast Fourier Transforms (FFTs), using real 64 bit arithmetic, by Paul Swarztrauber and Dick Valent;
- 
- **file_name_sequence**: demonstrates ways to generate a sequence of filenames, which can be useful when generating a sequence of still snapshots to be animated later.
- 
- **files_multiple**: demonstrates how a program can open multiple output files at one time, and write data to any one specific file it chooses.
- 
- **filon_rule**: uses Filon's method to approximate integrals which include an oscillatory factor of sin(k*x) or cos(k*x).
- 
- **filum**: performs various operations on files;
- 
- **fisher_exact**: returns an exact solution of the Kolmogorov Petrovsky Piskonov Fisher partial differential equation (PDE) ut=uxx+u*(1-u).
- 
- **fixcon**: converts the line continuation scheme used in a Fortran77 file to that used in Fortran90 files.
- 
- **flame_exact**: returns the exact solution of an ordinary differential equation (ODE) which models the growth of a ball of flame in a combustion process. The exact solution is defined in terms of the Lambert W function.
- 
- **floyd**: implements the Floyd algorithm for finding the shortest distance between pairs of nodes on a directed graph.
- 
- **football_dynamic**: uses dynamic programming to count the ways of achieving a given score in football.
- 
- **football_rank**: is given a set of game scores, and produces a ranking of college football teams.
- 
- **freefem_msh_io**: reads and writes files used by FreeFem++ to store mesh information for the finite element method (FEM).
- 
- **frieze**: demonstrates how to tile a 2D region with repeated copies of a given pattern.
- 
- **fsolve**: solves systems of nonlinear equations, inspired by the fsolve() function in minpack(), with special interfaces fsolve_bdf2(), fsolve_be() and fsolve_tr() for handling systems associated with implicit ODE solvers of type bdf2, backward Euler, midpoint, or trapezoidal.
- 
- **gauss_seidel**: implements the Gauss-Seidel iteration for linear systems.
- 
- **gegenbauer_cc**: computes the Gegenbauer weighted integral of a function f(x) using a Clenshaw-Curtis approach.
- 
- **gegenbauer_exactness**: tests the polynomial exactness of Gauss-Gegenbauer quadrature rules.
- 
- **gegenbauer_polynomial**: evaluates the Gegenbauer polynomial and associated functions.
- 
- **gegenbauer_rule**: computes and writes out a Gauss-Gegenbauer quadrature rule of given order.
- 
- **gen_hermite_exactness**: tests the polynomial exactness of generalized Gauss-Hermite quadrature rules.
- 
- **gen_hermite_rule**: computes and writes out a generalized Gauss-Hermite quadrature rule of given order and parameter value.
- 
- **gen_laguerre_exactness**: tests the polynomial exactness of generalized Gauss-Laguerre quadrature rules.
- 
- **gen_laguerre_rule**: computes and writes out a generalized Gauss-Laguerre quadrature rule of given order and parameter value.
- 
- **gene_cluster**: clusters sets of genetic expression data;
- 
- **geometry**: performs geometric calculations in 2, 3 and M dimensional space, including the computation of angles, areas, containment, distances, intersections, lengths, and volumes.
- 
- **geompack**: computes Delaunay triangulations, Voronoi diagrams, and other information, by Barry Joe.
- 
- **gl_fast_rule**: carries out the rapid computation of the Kth value and weight of an N point Gauss-Legendre quadrature rule, by Ignace Bogaert.
- 
- **glomin**: finds a global minumum of a scalar function of a scalar variable, without the use of derivative information, by Richard Brent.
- 
- **gmsh_io**: reads or writes some of the files created by gmsh() for 1D, 2D or 3D meshes used by the finite element method (FEM).
- 
- **gmsh_to_fem**: reads a mesh data file created by gmsh() and writes a pair of node and element files that correspond to the FEM format.
- 
- **graph_adj**: carries out operations on abstract graphs, with undirected edges, represented by an adjacency matrix. Operations include breadth-first search, the computation of a minimum spanning tree, an Euler or Hamilton circuit, blocks, chromatic polynomial, or transitive closure.
- 
- **graph_arc**: carries out operations on graphs. Information is stored in an arc list, pairs of nodes forming edges. Operations include the chromatic polynomial, computing degrees, computing the degree sequence, counting the edges, determining edge and node connectivity, Euler circuits, spanning trees, shortest path, printing the arc list, generating fixed and random examples.
- 
- **graph_code**: reads a table file representing the adjacency matrix of a graph, and computes the graph code.
- 
- **graph_dist**: carries out operations on abstract graphs, defined by undirected edges with an associated distance matrix.
- 
- **graph_paper**: makes PostScript (PS) graph paper;
- 
- **graph_theory**: carries out operations on abstract graphs, such as a breadth-first-search, the computation of a minimum spanning tree, an Euler or Hamilton circuit, blocks, chromatic polynomial, or transitive closure. Objects include undirected and directed graphs, weighted graphs, and trees.
- 
- **grf_io**: reads or writes a grf file which represents a mathematical graph;
- 
- **grf_to_eps**: converts a GRF file to Encapsulated PostScript (EPS) format;
- 
- **grf_to_xyl**: converts information describing the adjacency and embedding of an abstract graph from GRF to XYL format.
- 
- **haar_transform**: computes the Haar transform of 1d or 2d data.
- 
- **halton**: computes elements of a Halton Quasi Monte Carlo (QMC) sequence, using a simple interface.
- 
- **hammersley**: computes elements of a Hammersley Quasi Monte Carlo (QMC) sequence, using a simple interface.
- 
- **hankel_cholesky**: computes the upper Cholesky factor R of a symmetric positive definite (SPD) Hankel matrix H so that H = R' * R.
- 
- **hankel_spd**: computes a lower triangular matrix L that is the Cholesky factor of a symmetric positive definite (SPD) Hankel matrix H, that is, H = L * L'.
- 
- **hb_io**: reads and writes sparse linear systems stored in the Harwell Boeing (HB) format for sparse matrices.
- 
- **hb_to_st**: converts a sparse matrix from Harwell Boeing (HB) format to Sparse Triplet (ST) format.
- 
- **heat_mpi**: solves the 1D time dependent heat equation in parallel, using the Message Passing Interface (MPI).
- 
- **heated_plate**: solves the steady (time independent) heat equation in a 2D rectangular region, and is intended as a starting point for implementing a parallel version.
- 
- **heated_plate_openmp**: solves the steady (time independent) heat equation in a 2D rectangular region, using OpenMP to run in parallel.
- 
- **hello**: prints out "Hello, world!".
- 
- **hello_mpi**: prints 'Hello, world!' using the Message Passing Interface (MPI) for parallel execution.
- 
- **hello_openmp**: prints 'Hello, world!', using OpenMP for parallel execution.
- 
- **helmholtz_openmp**: solves the discretized Helmholtz equation in 2D using the OpenMP application program interface for carrying out parallel computations in a shared memory environment.
- 
- **hermite_cubic**: computes the value, derivatives or integral of a Hermite cubic polynomial, or manipulate an interpolating function made up of piecewise Hermite cubic polynomials.
- 
- **hermite_exactness**: tests the monomial exactness of quadrature rules for estimating Hermite-type integrals of a function f(x) with density rho(x)=exp(-x^2) over the interval (-oo,+oo).
- 
- **hermite_integrands**: defines test integrands for Hermite integrals with density exp(-x^2) over the interval (-oo,+oo).
- 
- **hermite_interpolant**: computes the Hermite interpolant, a polynomial that matches function values and derivatives.
- 
- **hermite_polynomial**: evaluates the physicist's Hermite polynomial, the probabilist's Hermite polynomial, the Hermite function, and related functions.
- 
- **hermite_product_polynomial**: defines Hermite product polynomials, creating a multivariate polynomial as the product of univariate Hermite polynomials.
- 
- **hex_grid**: computes points on a hexagonal grid.
- 
- **hex_grid_angle**: produces a hexagonal grid of points in the unit square or an arbitrary box, allowing the user to specify an arbitrary center, angle, and grid density.
- 
- **hexahedron_jaskowiec_rule**: returns a symmetric Jaskowiec quadrature rule for the hexahedron, with exactness up to total degree 21.
- 
- **hexahedron_witherden_rule**: returns a symmetric Witherden quadrature rule for the hexahedron, with exactness up to total degree 11.
- 
- **high_card_simulation**: simulates a situation in which you see the cards in a deck one by one, and must select the one you think is the highest and stop; using gnuplot() for graphics.
- 
- **hilbert_curve**: computes the sequence of discrete Hilbert curves whose limit is a space-filling curve.
- 
- **humps**: evaluates the humps function, its first and second derivatives, and its antiderivative.
- 
- **hyper_2f1**: evaluates the hypergeometric functions 2F1(a,b,c;x) for real or complex parameters a, b, c, and argument x, by N. Michel and M. Stoitsov.
- 
- **hyperball_integrals**: returns the exact value of the integral of any monomial over the interior of the unit hyperball in M dimensions.
- 
- **hyperball_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function over the interior of the unit ball in M dimensions;
- 
- **hypercube_exactness**: tests the polynomial exactness of a quadrature rule over the interior of the unit hypercube in M dimensions.
- 
- **hypercube_grid**: computes a grid of points over the interior of a hypercube in M dimensions.
- 
- **hypercube_integrals**: returns the exact value of the integral of any monomial over the interior of the unit hypercube in M dimensions.
- 
- **hypercube_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function over the interior of the unit hypercube in M dimensions.
- 
- **hypergeometric**: evaluates the generalized hypergeometric functions pFq, for integer p and q, for complex arguments of large magnitude, by Warren Perger, Atul Bhalla, and Mark Nardin.
- 
- **hypersphere**: carries out various operations for an M dimensional hypersphere, including converting between Cartesian and spherical coordinates, stereographic projection, sampling the surface of the sphere, and computing the surface area and volume.
- 
- **hypersphere_integrals**: returns the exact value of the integral of any monomial over the surface of the unit hypersphere in M dimensions.
- 
- **hypersphere_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function on the surface of the unit sphere in M dimensions;
- 
- **i4lib**: contains utilities which use single precision integer (I4) arithmetic.
- 
- **interp**: parameterizies and interpolates data;
- 
- **intlib**: carries out approximate integration (quadrature) in one dimension;
- 
- **is_prime**: implements various versions of the sieve of Eratosthenes to determine whether a given integer is prime.
- 
- **ising_2d_simulation**: carries out a Monte Carlo simulation of an Ising model, a 2D array of positive and negative charges, each of which is likely to flip to be in agreement with neighbors, using gnuplot() to make images of the initial and final configurations.
- 
- **ising_3d_simulation**: carries out a Monte Carlo simulation of an Ising model, a 3D array of positive and negative charges, each of which is likely to flip to be in agreement with neighbors.
- 
- **jacobi**: implements the Jacobi method for the iterative solution of linear systems.
- 
- **jacobi_eigenvalue**: implements the Jacobi iteration for the determination of the eigenvalues and eigenvectors of a real symmetric matrix.
- 
- **jacobi_exactness**: tests the monomial exactness of quadrature rules for integrals that include a Jacobi weight.
- 
- **jacobi_openmp**: uses OpenMP to parallelize a Jacobi iteration for solving A*x=b.
- 
- **jacobi_polynomial**: evaluates the Jacobi polynomial and associated functions.
- 
- **jacobi_rule**: computes and print a Gauss-Jacobi quadrature rule.
- 
- **kdv_exact**: evaluates exact solutions of the Korteweg-deVries (KdV) partial differential equation (PDE).
- 
- **kdv_ift**: uses the IFT method to solve the Korteweg-DeVries equation, by Aly-Khan Kassam, Lloyd Trefethen.
- 
- **ketel_one**: finds all words formed from the letters in "ketel one vodka";
- 
- **kmeans**: handles the K-Means problem, which organizes N points in M dimensions into K clusters;
- 
- **knapsack_01_brute**: uses brute force to solve small versions of the 0/1 knapsack problem, in which a knapsack of limited weight capacity is to be packed as full as possible, selecting items from a set of varying weights;
- 
- **knapsack_brute**: uses brute force to solve small versions of the knapsack problem, in which N items are available, each with given value and weight. A thief's knapsack can carry no more than Wmax pounds. The thief seeks a selection of items to carry in the knapsack of maximum total value.
- 
- **knapsack_random**: randomly chooses a subset of N items, each with given value and weight. It then evaluates whether this is a feasible solution to a problem in which a thief's knapsack can carry no more than Wmax pounds, and it is desired to maximum the total value of the selected items.
- 
- **knapsack_rational**: solves the rational knapsack problem, in which a knapsack of limited weight capacity is filled with profitable items. This variation of the 0/1 knapsack problem allows a fractional part of an item to be included in the knapsack. The result is an upper bound on the maximum possible profit for the 0/1 knapsack problem.
- 
- **knapsack_values**: returns some simple examples of the knapsack problem, in which N items are available, each with given value V and weight W. A thief's knapsack can carry no more than K pounds. The thief seeks a selection S of items to carry in the knapsack of maximum total value.
- 
- **kronrod_rule**: computes a Gauss and Gauss-Kronrod pair of quadrature rules of arbitrary order, by Robert Piessens, Maria Branders.
- 
- **l4lib**: contains functions for working with logical variables.
- 
- **lagrange_approx_1d**: evaluates the Lagrange polynomial p(x) of degree m which approximates n data points (x(i),y(i)).
- 
- **lagrange_interp_1d**: evaluates the Lagrange polynomial p(x) which interpolates data depending on a 1D argument, so that p(x(i)) = y(i).
- 
- **lagrange_interp_2d**: evaluates the Lagrange polynomial p(x,y) which interpolates data depending on a 2D argument that was evaluated on a product grid, so that p(x(i),y(j)) = z(i,j).
- 
- **lagrange_interp_nd**: evaluates the Lagrange polynomial p(x) which interpolates data depending on a multidimensional argument that was evaluated on a product grid, so that p(x(i)) = z(i).
- 
- **lagrange_nd**: implements several multivariate Lagrange interpolation schemes developed by Tomas Sauer.
- 
- **laguerre_exactness**: tests the monomial exactness of Gauss-Laguerre quadrature rules for estimating the integral of a function f(x) with density rho(x)=exp(-x) over the interval [0,+oo).
- 
- **laguerre_integrands**: implements test problems for Gauss-Laguerre quadrature rules for estimating the integral of a function with density exp(-x) over the interval [0,+oo).
- 
- **laguerre_polynomial**: evaluates the Laguerre polynomial, the generalized Laguerre polynomials, and the Laguerre function.
- 
- **laguerre_rule**: computes and print a Gauss-Laguerre quadrature rule for estimating the integral of a function with density exp(-x) over the interval [0,+oo).
- 
- **lambert_w**: evaluates Lambert's W function.
- 
- **lapack_d**: is the double precision real version of the lapack() linear algebra code.
- 
- **laplacian_matrix**: carries out computations related to the discrete Laplacian operator, including full or sparse evaluation, evaluation for unequally spaced data sampling points, application to data samples, solution of associated linear systems, eigenvalues and eigenvectors, and extension to 2D and 3D geometry.
- 
- **latin_center**: computes N points in an M dimensional Latin Center square;
- 
- **latin_cover**: produces N Latin squares which cover an NxN square, or NxN Latin cubes which cover an NxNxN cube.
- 
- **latin_edge**: returns N points in an M dimensional Latin Edge square;
- 
- **latin_random**: returns N points in an M dimensional Latin Random square;
- 
- **latinize**: adjusts N points in M dimensions to form a Latin hypercube;
- 
- **lattice_rule**: approximates M-dimensional integrals using lattice rules.
- 
- **lau_np**: implements heuristic algorithms for various NP-hard combinatorial problems, including the integer linear programming problem, the K-center problem, the K-median problem, the 0-1 knapsack problem, the multiple knapsack problem, the graph matching problem, the graph partitioning problem, the minimal Steiner tree problem, and the traveling salesman problem;
- 
- **laupack**: computes properties of mathematical graphs, including Euler circuits, Hamiltonian circuits, cliques, strongly connected components, minimal spanning tree, chromatic number, shortest paths, maximal flow, and planarity.
- 
- **lcvt**: computes a Latinized Centroidal Voronoi Tessellation (CVT).
- 
- **lebesgue**: is given nodes in 1D, and plots the Lebesgue function, and estimates the Lebesgue constant, which measures the maximum magnitude of the potential error of Lagrange polynomial interpolation, and which uses gnuplot() to make plots of the Lebesgue function.
- 
- **legendre_exactness**: tests the monomial exactness of quadrature rules for estimating Legendre-type integrals of a function f(x) with density rho(x)=1 over the interval [-1,+1].
- 
- **legendre_fast_rule**: uses a fast algorithm to compute a Gauss-Legendre quadrature rule for estimating the integral of a function with density rho(x)=1 over the interval [-1,+1].
- 
- **legendre_polynomial**: evaluates the Legendre polynomial and associated functions.
- 
- **legendre_product_polynomial**: defines Legendre product polynomials, creating a multivariate polynomial as the product of univariate Legendre polynomials.
- 
- **legendre_rule**: computes Gauss-Legendre quadrature rules for estimating the integral of a function with density rho(x)=1 over the interval [-1,+1].
- 
- **legendre_shifted_polynomial**: evaluates the shifted Legendre polynomial, with domain [0,1].
- 
- **levenshtein_distance**: returns the Levenshtein distance between two strings.
- 
- **levenshtein_matrix**: returns the Levenshtein distance matrix defined by two strings.
- 
- **line_cvt_lloyd**: applies the Lloyd iteration repeatedly to N points, to compute a Centroidal Voronoi Tessellation (CVT) over the interior of a line segment in 1D.
- 
- **line_fekete_rule**: estimates the location of N Fekete points, for polynomial interpolation or quadrature, over the interior of a line segment in 1D.
- 
- **line_felippa_rule**: returns a Felippa quadrature rule over the interior of a line segment in 1D.
- 
- **line_grid**: computes a grid of points over the interior of a line segment in 1D.
- 
- **line_integrals**: returns the exact value of the integral of any monomial over the length of the unit line in 1D.
- 
- **line_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function over the length of the unit line in 1D.
- 
- **line_ncc_rule**: computes a Newton Cotes Closed (NCC) quadrature rule, using equally spaced points, over the interior of a line segment in 1D.
- 
- **line_nco_rule**: computes a Newton Cotes Open (NCO) quadrature rule, using equally spaced points, over the interior of a line segment in 1D.
- 
- linear_algebra, Fortran90 codes which carry out various linear algebra operations for matrices stored in a variety of formats.
- 
- **linpack_bench**: carries out the LINPACK Benchmark.
- 
- **linpack_d**: factors and solves linear systems using double precision arithmetic, by Jack Dongarra, Jim Bunch, Cleve Moler, Pete Stewart. The matrix and vector data is assumed to be real.
- 
- **linpack_z**: factors and solves linear systems using double precision arithmetic, by Jack Dongarra, Jim Bunch, Cleve Moler, Pete Stewart. The matrix and vector data is assumed to be complex.
- 
- **llsq**: solves the simple linear least squares (LLS) problem of finding the formula of a straight line y=a*x+b which minimizes the root mean square error to N data points.
- 
- **lobatto_polynomial**: evaluates Lobatto polynomials, similar to Legendre polynomials except that they are zero at both endpoints.
- 
- **local_min**: finds a local minimum of a scalar function of a scalar variable, without the use of derivative information, by Richard Brent.
- 
- **local_min_rc**: finds a local minimum of a scalar function of a scalar variable, without the use of derivative information, using reverse communication (RC), by Richard Brent.
- 
- **log_normal**: returns quantities related to the log normal Probability Distribution Function (PDF).
- 
- **log_normal_truncated_ab**: returns quantities related to the log normal Probability Distribution Function (PDF) truncated to the interval [A,B].
- 
- **logistic_exact**: evaluates an exact solution of the logistic equation, an ordinary differential equation (ODE) which models population growth in the face of a limited carrying capacity.
- 
- **lorenz_ode**: approximates solutions to the Lorenz system of ordinary differential equations (ODE), creating output files that can be displayed by gnuplot().
- 
- **machar**: dynamically computes the values of various machine characteristic constants by William Cody;
- 
- **machine**: returns tabulated values of the constants associated with computer arithmetic;
- 
- **mandelbrot**: generates an ASCII Portable Pixel Map (PPM) image of the Mandelbrot fractal set;
- 
- **mandelbrot_openmp**: generates an ASCII Portable Pixel Map (PPM) image of the Mandelbrot fractal set, using OpenMP for parallel execution.
- 
- **matman**: allows a user to interactively define and manipulate matrices using integer, real, or rational arithmetic, and to perform various operations in linear algebra or linear programming modes.
- 
- **matmul**: benchmarks matrix multiplication.
- 
- **matrix_chain_brute**: finds the cost of the most efficient ordering to use when multiplying a sequence of matrices, using brute force.
- 
- **matrix_chain_dynamic**: finds the cost of the most efficient ordering to use when multiplying a sequence of matrices, using dynamic programming.
- 
- **matrix_exponential**: demonstrates some simple approaches to the problem of computing the exponential of a matrix;
- 
- **maze**: carries out operations on a maze, including the diameter, a random example, or a path that solves the maze.
- 
- **md**: carries out a molecular dynamics simulation, intended as a starting point for implementing a parallel version.
- 
- **md_openmp**: carries out a molecular dynamics simulation, using OpenMP for parallel execution.
- 
- **medit_mesh_io**: reads or writes medit() MESH files defining a finite element mesh.
- 
- **medit_to_fem**: reads a medit() MESH file and rewrites the information as an FEM file.
- 
- **mgmres**: applies the restarted Generalized Minimum Residual (GMRES) algorithm to solve a sparse linear system, using Compressed Row Storage (CRS) or sparse triplet (ST) format, by Lili Ju.
- 
- **mgs**: obscure legacy code, which the student is encouraged to study, understand, and document. This example is due to Diane O'Leary.
- 
- **middle_square**: implements the middle square algorithm for generating random integers. This is a very early method, attributed to von Neumann, which actually is deeply flawed, with short cycles.
- 
- **midpoint**: solves one or more ordinary differential equations (ODE) using the (implicit) midpoint method, with a version of fsolve() handling the associated nonlinear equation, and using a fixed time step.
- 
- **midpoint_adaptive**: solves one or more ordinary differential equations (ODE) using the (implicit) midpoint method, with fsolve() solving the implicit equation, and an adaptive time step. Plots of the solution and timestep history are created using gnuplot().
- 
- **midpoint_explicit**: solves one or more ordinary differential equations (ODE) using the (explicit) midpoint method, also called the modified Euler method.
- 
- **midpoint_fixed**: solves one or more ordinary differential equations (ODE) using the (implicit) midpoint method, using a fixed point iteration for the nonlinear equation.
- 
- **minpack**: solves systems of nonlinear equations, or the least squares minimization of the residual of linear or nonlinear equations, by Jorge More, Danny Sorenson, Burton Garbow, Kenneth Hillstrom.
- 
- **mm_io**: reads and writes sparse linear systems stored in the Matrix Market (MM) format.
- 
- **monomial**: enumerates, lists, ranks, unranks and randomizes multivariate monomials in a space of M dimensions, with total degree less than N, equal to N, or lying within a given range.
- 
- **monomial_value**: evaluates a monomial in M dimensions.
- 
- **multitask_mpi**: demonstrates how to multitask, that is, to execute several unrelated and distinct tasks simultaneously, using the message passing interface (MPI) for parallel execution.
- 
- **multitask_openmp**: demonstrates how to multitask, that is, to execute several unrelated and distinct tasks simultaneously, using OpenMP for parallel execution.
- 
- **mxm**: computes a dense matrix product C=A*B.
- 
- **mxm_openmp**: computes a dense matrix product C=A*B, using OpenMP for parallel execution.
- 
- **naca**: takes the parameters of certain NACA airfoils and returns the coordinates of a sequence of points that outline the wing shape. The data is displayed with the gnuplot() graphics program.
- 
- **nas**: runs the NASA kernel benchmark.
- 
- **navier_stokes_2d_exact**: evaluates an exact solution to the incompressible time-dependent Navier-Stokes equations (NSE) over an arbitrary domain in 2D.
- 
- **navier_stokes_3d_exact**: evaluates an exact solution to the incompressible time-dependent Navier-Stokes equations (NSE) over an arbitrary domain in 3D.
- 
- **nearest_interp_1d**: interpolates data using a piecewise constant interpolant defined by the nearest neighbor criterion, creating graphics files for processing by gnuplot().
- 
- **neighbors_to_metis_graph**: reads a file describing the neighbor structure of a mesh of triangles or tetrahedrons, and writes a metis_graph() file suitable for input to one of the family of programs based on metis();
- 
- **newton_interp_1d**: finds a polynomial interpolant to data using Newton divided differences.
- 
- **newton_rc**: solves a system of nonlinear equations by Newton's method, using reverse communication (RC).
- 
- **niederreiter2**: computes elements of a Niederreiter Quasi Monte Carlo (QMC) sequence using base 2.
- 
- **nint_exactness_mixed**: measures the exactness of an M-dimensional quadrature rule based on a mixture of 1D quadrature rule factors.
- 
- **nintlib**: implements approximate integration or quadrature in M dimensions;
- 
- **nms**: includes a wide variety of numerical software, including solvers for linear systems of equations, interpolation of data, numerical quadrature, linear least squares (LLS) data fitting, the solution of nonlinear equations, ordinary differential equations (ODE), optimization and nonlinear least squares (NLS), simulation and random numbers, trigonometric approximation and Fast Fourier Transforms (FFT).
- 
- **normal**: implements a random number generator (RNG) for normally distributed values;
- 
- **normal_dataset**: creates a multivariate normal random dataset and writes it to a file.
- 
- **obj_io**: reads and writes the 3D graphics information in an Alias OBJ file;
- 
- **ode**: solves a system of ordinary differential equations (ODE), by Shampine and Gordon;
- 
- **ornstein_uhlenbeck**: approximates solutions of the Ornstein-Uhlenbeck stochastic ordinary differential equation (SDE) using the Euler method and the Euler-Maruyama method, and creating graphics files for processing by gnuplot().
- 
- **owen**: evaluates the Owen T function.
- 
- **padua**: returns the coordinates of the 2D Padua points, as well as interpolation weights or quadrature weights, and images of the points in gnuplot() graphics files.
- 
- **partition_brute**: uses a brute force algorithm to seek solutions of the partition problem, splitting a set of integers into two subsets with equal sum.
- 
- **patterson_rule**: returns the points and weights of a 1D Gauss-Patterson quadrature rule of order 1, 3, 7, 15, 31, 63, 127, 255 or 511.
- 
- **pbma_io**: reads or writes graphics files that use the ASCII Portable Bit Map (PBM) format.
- 
- **pce_burgers**: solves a version of the time-dependent viscous Burgers equation, with uncertain viscosity, using a polynomial chaos expansion in terms of Hermite polynomials, by Gianluca Iaccarino.
- 
- **pce_ode_hermite**: sets up a simple scalar ordinary differential equation (ODE) for exponential decay with an uncertain decay rate, using a polynomial chaos expansion in terms of Hermite polynomials.
- 
- **pdb_to_xyz**: reads a Protein Data Bank (PDB) file, and, for each ATOM record in the file, extracts the atomic spatial coordinates and writes them to an XYZ file.
- 
- **pdflib**: evaluates Probability Density Functions (PDF) and produces random samples from them, including beta, binomial, chi, exponential, gamma, inverse chi, inverse gamma, multinomial, normal, scaled inverse chi, and uniform.
- 
- **pentominoes**: forms or plots any of the 12 members of the pentomino family, shapes formed from 5 adjacent squares.
- 
- **persistence**: demonstrates how to initialize, get, or set data stored within a function, using static/persistent/saved/local memory.
- 
- **pgma_io**: reads or writes graphics files that use the ASCII Portable Gray Map (PGM) format.
- 
- **pink_noise**: computes a pink noise signal obeying a 1/f power law.
- 
- **plot_points**: makes an Encapsulated PostScript (EPS) plot of points in 2D.
- 
- **plot_to_ps**: reads simple text commands and creates a PostScript (PS) image;
- 
- poisson_1d, a Fortran code which solves a discretized version of the Poisson equation -uxx = f(x) on the interval a  x  b, with Dirichlet boundary conditions u(a) = ua, u(b) = ub. The linear system is solved using Gauss-Seidel iteration.
- 
- **poisson_1d_multigrid**: applies the multigrid method to a discretized version of the 1D Poisson equation.
- 
- **poisson_2d**: solves the Poisson equation in a rectangle, using finite differences and Jacobi iteration.
- 
- **poisson_openmp**: computes an approximate solution to the Poisson equation in a rectangle, using the Jacobi iteration to solve the linear system, and OpenMP to carry out the Jacobi iteration in parallel.
- 
- **poisson_simulation**: simulates a Poisson process in which events randomly occur with an average waiting time of Lambda, creating output for graphics by gnuplot().
- 
- **polpak**: evaluates a variety of mathematical functions, polynomials, and sequences, including Bell, Benford, Bernoulli, Bernstein, Cardan, Catalan, Charlier, Chebyshev, Collatz, Delannoy, Euler, Fibonacci, Gegenbauer, Gudermannian, Harmonic, Hermite, Hofstadter, Hypergeometric 2F1, Jacobi, Krawtchouk, Laguerre, Lambert, Legendre, Lerch, Meixner, Mertens, Moebius, Motzkin, Phi, Stirling Number, Tau, Tribonacci, Zernike.
- 
- **polygon**: computes properties of an arbitrary polygon in the plane, defined by a sequence of vertices, including interior angles, area, centroid, containment of a point, convexity, counter clockwise ordering, diameter, distance to a point, inradius, lattice area, nearest point in set, outradius, uniform sampling, and triangulation.
- 
- **polygon_grid**: generates a grid of points over the interior of a polygon in 2D.
- 
- **polygon_integrals**: returns the exact value of the integral of any monomial over the interior of a polygon in 2D.
- 
- **polygon_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function over the interior of a polygon in 2D.
- 
- **polygon_triangulate**: triangulates a possibly nonconvex polygon in 2D, and which uses gnuplot() to display the external edges and internal diagonals of the triangulation.
- 
- **polynomial**: adds, multiplies, differentiates, evaluates and prints multivariate polynomials in a space of M dimensions.
- 
- **polynomial_conversion**: converts representations of a polynomial between monomial, Bernstein, Chebyshev, Gegenbauer, Hermite, Laguerre and Legendre forms.
- 
- **polynomial_root_bound**: computes the Cauchy bound on the magnitude of all roots of a polynomial with complex coefficients.
- 
- **polynomials**: defines multivariate polynomials over rectangular domains, for which certain information is to be determined, such as the maximum and minimum values.
- 
- **polyominoes**: manipulates polyominoes and tilings.
- 
- **porous_medium_exact**: returns an exact solution of the porous medium equation (PME), dudt=Del^2(u^m), a partial differential equation (PDE) related to the diffusion equation, based on the Barenblatt solution.
- 
- **power_method**: carries out the power method for finding a dominant eigenvalue and its eigenvector.
- 
- **power_rule**: constructs a power rule, that is, a product quadrature rule from identical 1D factor rules.
- 
- **ppma_io**: reads or writes graphics files that use the ASCII Portable Pixel Map (PPM) format.
- 
- **pppack**: computes piecewise polynomial functions, including cubic splines, by Carl deBoor.
- 
- **praxis**: minimizes a scalar function of several variables, without requiring derivative information, by Richard Brent.
- 
- **predator_prey_ode**: solves a time-dependent predator-prey system of ordinary differential equations (ODE).
- 
- **prime**: counts the number of primes between 1 and N, and is intended as a starting point for a parallel version.
- 
- **prime_mpi**: counts primes between 1 and N, using Message Passing Interface (MPI) for parallel execution.
- 
- **prime_openmp**: counts primes between 1 and N, using OpenMP for parallel execution.
- 
- **prime_pi**: evaluates Pi(n), the number of primes less than or equal to an integer n.
- 
- **prism_jaskowiec_rule**: returns symmetric quadrature rules, with exactness up to total degree 20, over the interior of a prism with triangular base, by Jan Jaskowiec, Natarajan Sukumar.
- 
- **prism_witherden_rule**: returns a symmetric Witherden quadrature rule for a prism with triangular base, with exactness up to total degree 10.
- 
- **prob**: evaluates, samples, inverts, and characterizes Probability Density Functions (PDF) and Cumulative Density Functions (CDF), including anglit, arcsin, benford, birthday, bernoulli, beta_binomial, beta, binomial, bradford, burr, cardiod, cauchy, chi, chi squared, circular, cosine, deranged, dipole, dirichlet mixture, discrete, empirical, english sentence and word length, error, exponential, extreme values, f, fisk, folded normal, frechet, gamma, generalized logistic, geometric, gompertz, gumbel, half normal, hypergeometric, inverse gaussian, laplace, levy, logistic, log normal, log series, log uniform, lorentz, maxwell, multinomial, nakagami, negative binomial, normal, pareto, planck, poisson, power, quasigeometric, rayleigh, reciprocal, runs, sech, semicircular, student t, triangle, uniform, von mises, weibull, zipf.
- 
- **product_rule**: constructs a product quadrature rule from distinct 1D factor rules.
- 
- **ps_gg_align**: implements global string alignment algorithms which work in linear space, and compute both the optimal score and the optimal alignment. Gaps in the alignment are assigned an affine gap penalty. The algorithms are due to Chao.
- 
- **ps_lg_align**: implements local string alignment algorithms which work in linear space, and compute both the optimal score and the optimal alignment. Gaps in the alignment are assigned an affine gap penalty. The algorithms are due to Chao.
- 
- **ps_qg_align**: implements quasi-global string alignment algorithms which work in linear space, and compute both the optimal score and the optimal alignment. Gaps in the alignment are assigned an affine gap penalty. The algorithms are due to Chao.
- 
- **ps_write**: creates PostScript (PS) graphics files.
- 
- **puzzles**: was used to solve various puzzles.
- 
- **pwl_approx_1d**: approximates data using a piecewise linear function.
- 
- **pwl_interp_1d**: interpolates data using a piecewise linear function.
- 
- **pwl_interp_2d**: evaluates a piecewise linear interpolant to data defined on a regular 2D grid.
- 
- **pwl_interp_2d_scattered**: evaluates a piecewise linear interpolant to data which is available at an irregularly arranged set of points.
- 
- **pwl_product_integral**: calculates the exact value of the integral of the product of two piecewise linear functions f(x) and g(x).
- 
- **pyramid_exactness**: computes the monomial exactness of a quadrature rule over the interior of a pyramid in 3D.
- 
- **pyramid_felippa_rule**: returns a Felippa quadrature rule for approximating integrals over the interior of a pyramid in 3D.
- 
- **pyramid_grid**: computes a grid of points over the interior of the unit pyramid in 3D;
- 
- **pyramid_integrals**: returns the exact value of the integral of any monomial over the interior of the unit pyramid in 3D.
- 
- **pyramid_jaskowiec_rule**: returns quadrature rules, with exactness up to total degree 20, over the interior of a pyramid in 3D, by Jan Jaskowiec, Natarajan Sukumar.
- 
- **pyramid_monte_carlo**: applies a Monte Carlo method to estimate integrals of a function over the interior of the unit pyramid in 3D;
- 
- **pyramid_rule**: computes a conical product quadrature rule over the interior of the unit pyramid in 3D;
- 
- **pyramid_witherden_rule**: returns a Witherden quadrature rule, with exactness up to total degree 10, over the interior of a pyramid.
- 
- **qr_solve**: computes the linear least squares (LLS) solution of a system A*x=b.
- 
- **quad_mpi**: approximates an integral using a quadrature rule, and carries out the computation in parallel using the Message Passing Interface (MPI).
- 
- **quad_openmp**: applies a quadrature rule to estimate an integral over a 1D interval, using OpenMP for parallel execution.
- 
- **quad_rule**: implements rules for approximate integration (quadrature) in one dimension;
- 
- **quad_serial**: approximates an integral using a quadrature rule, and is intended as a starting point for parallelization exercises.
- 
- **quad2d**: estimates an integral over a 2D rectangle using quadrature, intended as the starting point for program optimization or parallelization.
- 
- **quadmom**: computes a Gaussian quadrature rule for a weight function rho(x) based on the Golub-Welsch procedure that only requires knowledge of the moments of rho(x).
- 
- **quadpack**: estimates integrals using numerical quadrature, by Piessens, deDoncker-Kapenga, Ueberhuber, and Kahaner.
- 
- **quadrature_golub_welsch**: computes the points and weights of a Gaussian quadrature rule using the Golub-Welsch procedure, assuming that the points have been specified.
- 
- **quadrature_least_squares**: computes weights for sub-interpolatory quadrature rules, that is, it estimates integrals by integrating a polynomial that approximates the function data in a least squares sense.
- 
- **quadrature_weights_vandermonde**: computes the weights of a quadrature rule using the Vandermonde matrix, assuming that the points have been specified.
- 
- **quadrature_weights_vandermonde_2d**: computes the weights of a 2D quadrature rule using the Vandermonde matrix, assuming that the points have been specified.
- 
- **quadrilateral_mesh**: handles meshes of quadrilaterals over a 2D region;
- 
- **quadrilateral_mesh_rcm**: computes the Reverse Cuthill McKee (RCM) reordering for nodes in a mesh of 4-node quadrilaterals.
- 
- **quadrilateral_witherden_rule**: returns a symmetric Witherden quadrature rule for the quadrilateral, with exactness up to total degree 21.
- 
- **quality**: computes quality of distribution measures for pointsets in M dimensions;
- 
- **quaternions**: carries out some simple arithmetic operations for quaternions.
- 
- **quotes**: prints a random quote from a file;
- 
- **r83**: contains linear algebra routines for r83 matrices (real, 64 bit, tridiagonal 3xN format).
- 
- **r83_np**: contains linear algebra routines for r83_np matrices (real, 64 bit, tridiagonal 3xN format, nonpivoting factorization).
- 
- **r83p**: contains linear algebra routines for r83p matrices (real, 64 bit, tridiagonal periodic format).
- 
- **r83s**: contains linear algebra routines for r83s matrices (real, 64 bit, tridiagonal scalar format).
- 
- **r83t**: contains linear algebra routines for r83t matrices (real, 64 bit, tridiagonal Mx3 format).
- 
- **r83v**: contains linear algebra routines for r83v matrices (real, 64 bit, tridiagonal three vector format).
- 
- **r85**: contains linear algebra routines for r85 matrices (real, 64 bit, pentadiagonal format).
- 
- **r8bb**: contains linear algebra routines for r8bb matrices (real, 64 bit, border banded format).
- 
- **r8blt**: contains linear algebra routines for r8blt matrices (real, 64 bit, band lower triangular format).
- 
- **r8bto**: contains linear algebra routines for r8bto matrices (real, 64 bit, block Toeplitz format).
- 
- **r8but**: contains linear algebra routines for r8but matrices (real, 64 bit, band upper triangular format).
- 
- **r8cb**: contains linear algebra routines for r8cb matrices (real, 64 bit, Compressed Band format).
- 
- **r8cbb**: contains linear algebra routines for r8cbb matrices (real, 64 bit, Compressed Border Banded format).
- 
- **r8ccs**: contains linear algebra routines for r8ccs matrices (real, 64 bit, Compressed Column Storage (Colptr,Row,Value) format).
- 
- **r8ci**: contains linear algebra routines for r8ci matrices (real, 64 bit, circulant format).
- 
- **r8col**: contains utility routines for an R8COL, that is, a double precision real MxN array, considered as N column vectors, each of length M. The data may be thought of as a matrix of multiple columns, and many operations will be carried out columnwise.
- 
- **r8gb**: contains linear algebra routines for r8gb matrices (real, 64 bit, General Banded format).
- 
- **r8gd**: contains linear algebra routines for r8gd matrices (real, 64 bit, general diagonal format).
- 
- **r8ge**: contains linear algebra routines for R8GE matrices (real, 64 bit, General format).
- 
- **r8lib**: contains many utility routines, using double precision real (R8) arithmetic.
- 
- **r8lt**: contains linear algebra routines for R8LT matrices (real, 64 bit, Lower Triangular).
- 
- **r8ltt**: contains linear algebra routines for r8ltt matrices (real, 64 bit, lower triangular Toeplitz format).
- 
- **r8ncf**: contains linear algebra routines for r8ncf matrices (real, 64 bit, nonsymmetric coordinate format).
- 
- **r8pbl**: contains linear algebra routines for r8pbl matrices (real, 64 bit, symmetric positive definite (SPD) band lower format).
- 
- **r8pbu**: contains linear algebra routines for r8pbu matrices (real, 64 bit, symmetric positive definite (SPD) band upper format).
- 
- **r8po**: contains linear algebra routines for r8po matrices (real, 64 bit, symmetric positive definite (SPD) format).
- 
- **r8poly**: operates on real polynomials, including evaluation, differentiation, integration, multiplication, synthetic division, shifting the base, computing a power, taking the norm. It also defines Chebyshev, Lagrange and Legendre polynomials.
- 
- **r8pp**: contains linear algebra routines for r8pp matrices (real, 64 bit, symmetric positive definite (SPD) packed format).
- 
- **r8ri**: contains linear algebra routines for r8ri matrices (real, 64 bit, row indexed format).
- 
- **r8row**: contains utilities for an R8ROW, that is, a double precision real MxN array, considered as M row vectors, each of length N. The data may be thought of as a matrix of multiple rows, and many operations will be carried out rowwise.
- 
- **r8sd**: contains linear algebra routines for r8sd matrices (real, 64 bit, symmetric diagonal format).
- 
- **r8sm**: contains linear algebra routines for r8sm matrices (real, 64 bit, Sherman-Morrison A-u*v' format).
- 
- **r8sr**: carries out linear algebra operations for r8sr matrices (real, 64 bit, diagonal + compressed row offdiagonal format).
- 
- **r8ss**: carries out linear algebra operations for r8ss matrices (real, 64 bit, symmetric skyline format).
- 
- **r8st**: contains linear algebra routines for R8ST matrices (real, 64 bit, Sparse Triplet).
- 
- **r8sto**: contains linear algebra routines for r8sto matrices (real, 64 bit, symmetric Toeplitz N format).
- 
- **r8to**: contains linear algebra routines for r8to matrices (real, 64 bit, Toeplitz 2*N-1 format).
- 
- **r8ut**: contains linear algebra routines for r8ut matrices (real, 64 bit, Upper Triangular).
- 
- **r8utp**: carries out linear algebra operations on r8utp matrices, real 64 bit, Upper Triangular Packed format.
- 
- **r8utt**: contains linear algebra routines for r8utt matrices (real, 64 bit, upper triangular Toeplitz format).
- 
- **r8vm**: contains linear algebra routines for r8vm matrices (real, 64 bit, Vandermonde format).
- 
- **randlc**: implements a random number generator (RNG) used by the nas() benchmarks.
- 
- **random_data**: uses a random number generator (RNG) to sample points distributed according to various probability density functions (PDF), spatial dimensions, and geometries, including the M-dimensional cube, ellipsoid, simplex and sphere.
- 
- **random_mpi**: generates the same sequence of values from a random number generator (RNG) for both sequential execution and parallel execution under the Message Passing Interface (MPI).
- 
- **random_openmp**: generates multiple distinct streams of random numbers using OpenMP for parallel execution.
- 
- **random_sorted**: uses a random number generator (RNG) to create a vector of random values which are already sorted.
- 
- **ranlib**: library of random number generators which produces random samples from Probability Density Functions (PDF), including Beta, Chi-square Exponential, F, Gamma, Multivariate normal, Noncentral chi-square, Noncentral F, Univariate normal, random permutations, Real uniform, Binomial, Negative Binomial, Multinomial, Poisson and Integer uniform, by Barry Brown and James Lovato.
- 
- **ranmap**: creates PostScript (PS) images of iterated affine mappings, including the Barnsley fractal fern and the Levy dragon.
- 
- **rbf_interp_1d**: defines and evaluates radial basis function (RBF) interpolants to 1D data.
- 
- **rbf_interp_2d**: defines and evaluates radial basis function (RBF) interpolants to 2D data.
- 
- **rbf_interp_nd**: defines and evaluates radial basis function (RBF) interpolants to multidimensional data.
- 
- **rcm**: applies the Reverse Cuthill McKee (RCM) algorithm for reordering the nodes of a graph, and reducing the bandwidth of a corresponding sparse matrix;
- 
- **reactor_simulation**: simple Monte Carlo simulation of the shielding effect of a slab of a certain thickness in front of a neutron source. This was provided as an example with the book 'Numerical Methods and Software'.
- 
- **reformat**: makes a copy of a file with a given number of words per line.
- 
- **region**: reads 3D magnetic resonance imaging (MRI) voxel data, and groups the voxels into connected regions, called components or segments;
- 
- **ring_mpi**: uses the Message Passing Interface (MPI), and measures the time necessary to copy data around a ring of processes.
- 
- **rk1**: solves one or more ordinary differential equations (ODE) using an explicit Runge-Kutta method of order 1, usually known as Euler's explicit method.
- 
- **rk1_implicit**: solves one or more ordinary differential equations (ODE) using the Runge-Kutta order 1 implicit method, using fsolve() to solve the implicit equation, and using a fixed time step. rk1_implicit() is commonly called the backward Euler method.
- 
- **rk2**: solves one or more ordinary differential equations (ODE) using an explicit Runge-Kutta method of order 2, also known as Heun's method, the modified Euler method, or the explicit midpoint method.
- 
- **rk2_implicit**: solves one or more ordinary differential equations (ODE) using the Runge-Kutta order 2 implicit method, using fsolve() to solve the implicit equation, and using a fixed time step. rk2_implicit() is also known as the implicit midpoint method.
- 
- **rk4**: applies the fourth order Runge-Kutta (RK) algorithm to estimate the solution of an ordinary differential equation (ODE).
- 
- **rkf45**: applies a Runge-Kutta-Fehlberg (RKF) solver to a system of ordinary differential equations (ODE);
- 
- **rnglib**: implements a random number generator (RNG) with splitting facilities, allowing multiple independent streams to be computed, by L'Ecuyer and Cote.
- 
- **root_rc**: seeks a solution of a scalar nonlinear equation f(x) = 0, or a system of nonlinear equations, using reverse communication (RC), by Gaston Gonnet.
- 
- **roots_rc**: seeks a solution of a system of nonlinear equations f(x) = 0, using reverse communication (RC), by Gaston Gonnet.
- 
- **row_echelon_integer**: carries out the exact computation of the integer row echelon form (IREF) and integer reduced row echelon form (IRREF) of an integer matrix.
- 
- **rref2**: computes the reduced row echelon form (RREF) of a matrix, which can be used to analyze matrices which are square or rectangular, singular or invertible.
- 
- **sandia_cubature**: computes M-dimensional quadrature rules for certain regions and weight functions.
- 
- **sandia_cvt**: positions a given number of points in an arbitrary region, using probabilistic Centroidal Voronoi Tessellation (CVT) techniques to achieve good coverage and separation; developed for Sandia National Laboratory;
- 
- **sandia_rules**: produces 1D quadrature rules of Chebyshev, Clenshaw Curtis, Fejer 2, Gegenbauer, generalized Hermite, generalized Laguerre, Hermite, Jacobi, Laguerre, legendre and Patterson types.
- 
- **sandia_sgmgg**: explores a generalized construction method for sparse grids.
- 
- **sandia_sparse**: produces a M-dimensional sparse grid, based on a variety of 1D quadrature rules; only isotropic grids are generated, that is, the same rule is used in each dimension, and the same maximum order is used in each dimension.
- 
- **satisfy_brute**: uses brute force to find all assignments of values to a set of logical variables which make a complicated logical statement true.
- 
- **satisfy_mpi**: demonstrates, for a particular circuit, an exhaustive search for solutions of the circuit satisfiability problem, using the Message Passing Interface (MPI) to work in parallel.
- 
- **satisfy_openmp**: demonstrates, for a particular circuit, an exhaustive search for solutions of the circuit satisfiability problem, using OpenMP for parallel execution.
- 
- **schedule_openmp**: demonstrates the default, static, and dynamic methods of scheduling loop iterations in OpenMP to avoid work imbalance.
- 
- **sde**: illustrates properties of stochastic ordinary differential equations (SODE), and common algorithms for their analysis, including the Euler method, the Euler-Maruyama method, and the Milstein method, making graphics files for processing and display by gnuplot(), by Desmond Higham;
- 
- **search_mpi**: searches integers between A and B for a value J such that F(J) = C, using MPI for parallel execution.
- 
- **set_theory**: demonstrates various set theoretic operations using several models of a set.
- 
- **sftpack**: implements the slow Fourier transform, intended as a teaching tool and comparison with the Fast Fourier Transform (FFT).
- 
- **sgmga**: creates sparse grids based on a mixture of 1D quadrature rules, allowing anisotropic weights for each dimension.
- 
- **shallow_water_1d**: simulates the evolution of a 1D fluid governed by the time-dependent shallow water equations.
- 
- **shepard_interp_1d**: defines and evaluates Shepard interpolants to 1D data, based on inverse distance weighting.
- 
- **shepard_interp_2d**: defines and evaluates Shepard interpolants to 2D data, based on inverse distance weighting.
- 
- **shepard_interp_nd**: defines and evaluates Shepard interpolants to multidimensional data, based on inverse distance weighting.
- 
- **sigmoid_derivative**: evaluates derivatives of any order for the sigmoid function s(x)=1/(1+exp(-x)). The test code creates graphics images using gnuplot().
- 
- **simplex_coordinates**: computes the Cartesian coordinates of the vertices of a regular simplex in M dimensions.
- 
- **simplex_gm_rule**: defines Grundmann-Moeller quadrature rules over the interior of a triangle in 2D, a tetrahedron in 3D, or a simplex in M dimensions.
- 
- **simplex_grid**: generates a regular grid of points over the interior of an arbitrary simplex in M dimensions.
- 
- **simplex_integrals**: returns the exact value of the integral of any monomial over the interior of the unit simplex in M dimensions.
- 
- **simplex_monte_carlo**: uses the Monte Carlo method to estimate an integral over the interior of the unit simplex in M dimensions.
- 
- **sine_gordon_exact**: returns an exact solution of the Sine-Gordon equation, a partial differential equation (PDE) of the form uxy=sin(u).
- 
- **sine_transform**: demonstrates some simple properties of the discrete sine transform (DST).
- 
- **slap**: forms the Sparse Linear Algebra Package (SLAP), for the iterative solution of sparse linear systems, by Anne Greenbaum and Mark Seager.
- 
- **slap_io**: reads and writes sparse matrix files in the SLAP format;
- 
- **slatec**: collects standard numerical libraries, including blas(), bvsup(), dassl(), depac(), drive(), eispack(), fftpack(), fishpack(), fnlib(), linpack(), machine(), minpack(), mp(), pchip(), pppack(), quadpack(), slap(), sos(), splp(), and xerror().
- 
- **snakes_and_ladders**: provides tools for the study of the game of Snakes and Ladders.
- 
- **sncndn**: evaluates the Jacobi elliptic functions sn(u,m), cn(u,m), and dn(u,m).
- 
- **sobol**: computes elements of a Sobol Quasi Monte Carlo (QMC) sequence, by Bennett Fox.
- 
- **solve**: demonstrates how Gauss elimination can be used to solve a linear system A*x=b.
- 
- **sort_rc**: sorts a list of any kind of objects, using reverse communication (RC).
- 
- **spaeth**: analyzes data by grouping it into clusters.
- 
- **spaeth2**: analyzes data by grouping it into clusters.
- 
- **sparse_count**: analyzes sparse grids in which a single family of 1D quadrature rules is used for all spatial dimensions, with a variety of growth rules.
- 
- **sparse_display**: reads information defining a matrix of numbers and display the sparsity pattern or location of the nonzero elements using gnuplot(). This operation is similar to the MATLAB spy() command.
- 
- **sparse_grid_cc**: creates sparse grids based on Clenshaw-Curtis rules.
- 
- **sparse_grid_gl**: creates sparse grids based on Gauss-legendre rules.
- 
- **sparse_grid_hermite**: creates sparse grids based on Gauss-Hermite rules.
- 
- **sparse_grid_hw**: creates sparse grids based on Gauss-Legendre, Gauss-Hermite, Gauss-Patterson, or a nested variation of Gauss-Hermite rules, by Florian Heiss and Viktor Winschel.
- 
- **sparse_grid_laguerre**: creates sparse grids based on Gauss-Laguerre rules.
- 
- **sparse_grid_mixed**: creates a sparse grid dataset based on a mixed set of 1D factor rules.
- 
- **sparse_interp_nd**: defines a sparse interpolant to a function f(x) of a multidimensional argument.
- 
- **sparsekit**: implements operations on sparse matrices, including conversion between various formats, by Yousef Saad.
- 
- **specfun**: computes special functions, including Bessel I, J, K and Y functions, and the Dawson, E1, EI, Erf, Gamma, log Gamma, Psi/Digamma functions, by William Cody and Laura Stoltz;
- 
- **special_functions**: evaluates special functions, including Airy, Associated Legendre, Bernoulli Numbers, Bessel, Beta, Complete Elliptic Integral, Cosine Integral, Elliptic Integral, Error, Euler Numbers, Exponential Integral, Fresnel Integral, Gamma, Hankel, Hermite polynomials, Hypergeometric 2F1, Incomplete Beta, Incomplete Gamma, Jacobian Elliptic, Kelvin, Kummer Confluent Hypergeometric, Laguerre polynomials, Lambda, Legendre functions, Legendre polynomials, Mathieu, Modified Spherical Bessel, Parabolic Cylinder, Psi, Riccati-Bessel, Sine Integral, Spheroidal Angular, Spheroidal Wave, Struve, Tricomi Confluent Hypergeometric, Whittaker, by Shanjie Zhang, Jianming Jin;
- 
- **sphere_cubed_grid**: uses the projection of a cube to create grids of points, lines, and quadrilaterals on the surface of the unit sphere in 3D.
- 
- **sphere_cvt**: uses a Centroidal Voronoi Tessellation (CVT) to generate a mesh of well-separated points on the surface of the unit sphere in 3D.
- 
- **sphere_delaunay**: reads a file containing the coordinates of points on the surface of the unit sphere in 3D, computes the Delaunay triangulation, and outputs a PostScript (PS) file of the image;
- 
- **sphere_design_rule**: returns point sets on the surface of the unit sphere in 3D, known as designs, which estimate integrals.
- 
- **sphere_exactness**: tests the monomial exactness of a quadrature rule over the surface of the unit sphere in 3D.
- 
- **sphere_fibonacci_grid**: uses a Fibonacci spiral to create a grid of points on the surface of the unit sphere in 3D.
- 
- **sphere_grid**: generates grids of points, or of points and lines, or of points and lines and faces, on the surface of the unit sphere in 3D.
- 
- **sphere_integrals**: returns the exact value of the integral of any monomial over the surface of the unit sphere in 3D.
- 
- **sphere_lebedev_rule**: computes Lebedev quadrature rules on the surface of the unit sphere in 3D.
- 
- **sphere_llq_grid**: uses longitudes and latitudes to create grids of points, lines, and quadrilaterals on the surface of the unit sphere in 3D.
- 
- **sphere_llt_grid**: uses longitudes and latitudes to create grids of points, lines, and triangles on the surface of the unit sphere in 3D.
- 
- **sphere_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function on the surface of the unit sphere in 3D;
- 
- **sphere_quad**: uses triangulation to approximate an integral on the surface of the unit sphere in 3D;
- 
- **sphere_stereograph**: computes the stereographic mapping between points on the surface of the unit sphere in 3D and points on the plane Z = 1; a generalized mapping is also available.
- 
- **sphere_triangle_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function over a spherical triangle on the surface of the unit sphere in 3D;
- 
- **sphere_triangle_quad**: uses quadrature to estimate the integral of a function over a spherical triangle on the surface of the unit sphere in 3D.
- 
- **sphere_voronoi**: reads a file containing the coordinates of points on the surface of the unit sphere in 3D, computes the Voronoi diagram, and outputs a PostScript (PS) file of the image;
- 
- **spiral_exact**: computes a 2D velocity vector field that is an exact solution of the continuity equation.
- 
- **spline**: interpolates and approximates via splines;
- 
- **square_arbq_rule**: returns quadrature rules, with exactness up to total degree 20, over the interior of the symmetric square in 2D, by Hong Xiao and Zydrunas Gimbutas.
- 
- **square_exactness**: computes the polynomial exactness of quadrature rules for f(x,y) over the interior of a quadrilateral in 2D.
- 
- **square_felippa_rule**: returns a Felippa quadrature rule over the interior of a square in 2D.
- 
- **square_grid**: computes a grid of points over the interior of a square in 2D.
- 
- **square_hex_grid**: computes a hexagonal grid of points over the interior of a square in 2D.
- 
- **square_integrals**: returns the exact value of the integral of any monomial over the interior of the unit square or symmetric unit square in 2D.
- 
- **square_minimal_rule**: returns almost minimal quadrature rules, with exactness up to total degree 55, over the interior of the symmetric square in 2D, by Mattia Festa and Alvise Sommariva.
- 
- **square_monte_carlo**: applies a Monte Carlo method to estimate the integral of a function over the interior of the unit square in 2D.
- 
- **square_symq_rule**: returns symmetric quadrature rules, with exactness up to total degree 20, over the interior of the symmetric square in 2D, by Hong Xiao and Zydrunas Gimbutas.
- 
- **ss_gd_align**: implements some of the linear space alignment algorithms described in the reference by Chao.
- 
- **ss_gg_align**: implements the sequence/sequence global gap alignment, one of the string matching algorithms described in the reference by Chao.
- 
- **ss_lg_align**: implements the sequence/sequence local alignment, one of the string matching algorithms described by Chao.
- 
- **ss_qg_align**: implements the sequence/sequence global gap alignment, one of the string matching algorithms described by Chao.
- 
- **st_io**: reads and writes sparse linear systems stored in the Sparse Triplet (ST) format.
- 
- **st_to_ccs**: converts sparse matrix data from Sparse Triplet (ST) format to Compressed Column Storage (CCS) format;
- 
- **st_to_hb**: converts a sparse matrix file from Sparse Triplet (ST) format to Harwell Boeing (HB) format;
- 
- **starpac**: performs statistical data analysis. It includes functions for nonlinear least squares regression, time series analysis in both time and frequency domains), line printer graphics, basic statistical analysis, and linear least squares regression, by Janet Donaldson.
- 
- **steam**: computes steam table properties including pressure and density, based on a National Bureau of Standards (NBS) package;
- 
- **steam_interact**: allows the user to interactively query the steam table functions from the National Bureau of Standards (NBS).
- 
- **stiff_ode**: considers an ordinary differential equation (ODE) which is an example of a stiff ODE.
- 
- **stla_io**: reads and writes the 3D graphics information in an ASCII stereolithography (STL) file;
- 
- **stochastic_diffusion**: implements several versions of a stochastic diffusivity coefficient, using gnuplot() to create graphic images of sample realizations of the diffusivity field.
- 
- **stochastic_heat2d**: implements a finite difference method (FDM) for the steady 2D heat equation, with a stochastic heat diffusivity coefficient.
- 
- **stochastic_rk**: applies a Runge-Kutta (RK) scheme to a stochastic ordinary differential equation (SDE).
- 
- **stokes_2d_exact**: evaluates exact solutions to the incompressible steady Stokes equations over the unit square in 2D.
- 
- **string_pde**: sets up and solves the partial differential equations (PDE) describing a vibrating string, creating files that can be displayed by gnuplot().
- 
- **stripack**: computes the Delaunay triangulation or Voronoi diagram of points on a unit sphere, by Robert Renka.
- 
- **stripack_bench**: times the execution of stripack()'s Delaunay triangulation procedure over the surface of a sphere, for a random set of N nodes.
- 
- **stripack_delaunay**: reads points on the unit sphere, calls stripack() to compute the Delaunay triangulation, and writes it to a file.
- 
- **stripack_voronoi**: reads points on the unit sphere, computes the Voronoi diagram, and writes it to a file.
- 
- **stroud_rule**: defines quadrature rules for a variety of M-dimensional regions, including the interior of the square, cube and hypercube, the pyramid, cone and ellipse, the hexagon, the M-dimensional octahedron, the circle, sphere and hypersphere, the triangle, tetrahedron and simplex, and the surface of the circle, sphere and hypersphere.
- 
- **subanagram**: finds words which are anagrams formed from some of the letters of a given master word.
- 
- **subpak**: includes a number of utility routines.
- 
- **subset**: enumerates, generates, randomizes, ranks and unranks combinatorial objects including combinations, compositions, Gray codes, index sets, partitions, permutations, polynomials, subsets, and Young tables. Backtracking routines are included to solve some combinatorial problems.
- 
- **subset_sum**: seeks solutions of the subset sum problem, in which it is desired to find a subset of integers which has a given sum.
- 
- **subset_sum_backtrack**: uses backtracking to find solutions of the subset sum problem, in which it is desired to find a subset of integers which has a given sum.
- 
- **subset_sum_brute**: uses brute force to find solutions of the subset sum problem, in which it is desired to find a subset of integers which has a given sum.
- 
- **subset_sum_swap**: uses swapping to try to improve an initial estimated solution of the subset sum problem, which seeks a subset of a set of integers which has a given sum. Even when an exact solution exists, this approach often only finds an approximate solution.
- 
- **svd_basis**: applies the singular value decomposition (SVD) to a collection of data vectors, extracting dominant modes;
- 
- **svd_basis_weight**: applies the singular value decomposition (SVD) to a collection of weighted data vectors, extracting dominant modes;
- 
- **svd_snowfall**: reads a file containing historical snowfall data and analyzes the data with the Singular Value Decomposition (SVD), displaying the results using gnuplot().
- 
- **svd_truncated**: demonstrates the computation of the reduced or truncated Singular Value Decomposition (SVD) that is useful for cases when one dimension of the matrix is much smaller than the other.
- 
- **table_columns**: reads a table file of N points in M dimensions and creates a new file by copying various columns, with repetition and shuffling;
- 
- **table_io**: reads and writes data as a table file.
- 
- **table_quality**: reads a table file of N points in M dimensions and computes the uniformity of the placement of the points;
- 
- **table_top**: displays patterns in a set of N points in M dimensions.
- 
- **tec_io**: reads or writes a tecplot() ASCII TEC file containing a model associated with the finite element method (FEM).
- 
- **tec_to_fem**: converts a tecplot ASCII file into an FEM model.
- 
- **test_approx**: implements test problems for approximation, provided as (x,y) data.
- 
- **test_con**: defines tests for the continuation problem, which considers a function F(X) with N-dimensional argument X and N-1 dimensional result. In general, this defines an implicit one-dimensional curve of solutions X(LAMBDA). A continuation code starts from a single point on this curve and tries to compute a sequence of solutions that form a path.
- 
- **test_eigen**: implements test matrices for eigenvalue analysis.
- 
- **test_int**: implements test problems for approximate integration in one dimension.
- 
- **test_int_2d**: implements test problems for approximate integration in two dimensions.
- 
- **test_interp**: defines test problems for interpolation, provided as (x,y(x)) data.
- 
- **test_interp_1d**: defines test problems for interpolation of data y(x), which depends on a 1D argument.
- 
- **test_interp_2d**: defines test problems for interpolation of data z(x,y), depending on a 2D argument.
- 
- **test_interp_nd**: defines test problems for interpolation of data z(x), depending on an M-dimensional argument.
- 
- **test_lls**: implements linear least squares (LLS) test problems of the form A*x=b.
- 
- **test_matrix**: defines test matrices for which the condition number, determinant, eigenvalues, eigenvectors, inverse, null vectors, P*L*U factorization or linear system solution are known. Examples include the Fibonacci, Hilbert, Redheffer, Vandermonde, Wathen and Wilkinson matrices.
- 
- **test_matrix_exponential**: defines test cases for computing the matrix exponential.
- 
- **test_mesh**: implements some sample 2D meshes.
- 
- **test_min**: implements test problems for minimization of a scalar function of a scalar variable.
- 
- **test_nearest**: tests the time complexity of various procedures for solving the nearest neighbor problem.
- 
- **test_nint**: implements test problems for approximate integration (quadrature) in M dimensions.
- 
- **test_nls**: implements nonlinear least squares (NLS) test problems.
- 
- **test_nonlin**: implements test problems for the solution of systems of nonlinear equations.
- 
- **test_ode**: defines a set of test initial value problems for ordinary differential equations (ODE).
- 
- **test_opt**: implements test problems for optimization of a scalar function of several variables.
- 
- **test_opt_con**: defines test problems for the minimization of a scalar function of several variables, with the search constrained to lie within a specified hyper-rectangle.
- 
- **test_optimization**: implements test problems for optimization of a scalar function of several variables, as described by Molga and Smutnicki.
- 
- **test_partial_digest**: generates cases of the partial digest problem.
- 
- **test_tet_mesh**: implements test problems for tetrahedralization or meshing of arbitrary regions in 3 dimensions.
- 
- **test_triangulation**: implements test problems for triangularization or meshing of arbitrary regions in 2 dimensions.
- 
- **test_values**: supplies test values of various mathematical functions, including Abramowitz, AGM, Airy, Bell, Bernoulli, Bessel, Beta, Binomial, Bivariate Normal, Catalan, Cauchy, Chebyshev, Chi Square, Clausen, Clebsch Gordan, Collatz, Cosine integral, Dawson, Debye, Dedekind, dilogarithm, Dixon elliptic functions, Exponential integral, Elliptic, Error, Euler, Exponential integral, F probability, Fresnel, Frobenius, Gamma, Gegenbauer, Goodwin, Gudermannian, Harmonic, Hermite, Hypergeometric 1F1, Hypergeometric 2F1, inverse trigonometic, Jacobi Elliptic functions sn(), cn(), dn(), the Julian Ephemeris Date, Kelvin, Knapsack, Laguerre, Lambert W, Laplace, Legendre, Lerch, Lobachevsky, Lobatto, Logarithmic integral, Log normal, McNugget numbers, Mersenne primes, Mertens, Mittag-Leffler, Moebius, Multinomial, Negative binomial, Nine J, Normal, Omega, Owen, Partition, Phi, Pi, Poisson, Polylogarithm, Polynomial Resultant, Polyomino, Prime, Psi, Rayleigh, Hyperbolic Sine integral, Sigma, Sine Power integral, Sine integral, Six J, Sphere area, Sphere volume, Spherical harmonic, Stirling, Stromgen, Struve, Student, Subfactorial, Student probability, Three J, Transport, Trigamma, Truncated normal, van der Corput, von Mises, Weibull, Wright Omega, Zeta.
- 
- **test_zero**: implements test problems for the solution of a single nonlinear equation in one variable.
- 
- tester, a BASH script which runs the test codes.
- 
- **tet_mesh**: carries out various tasks associated with tetrahedral meshes in 3D;
- 
- **tet_mesh_boundary**: determines the triangular mesh that bounds a tet mesh.
- 
- **tet_mesh_quad**: estimates the integral of a function over a region defined by a tetrahedral mesh.
- 
- **tet_mesh_quality**: reads information about a tet mesh of points in 3D and computes various quality measures;
- 
- **tet_mesh_to_gmsh**: writes a tetrahedral mesh to a gmsh() file.
- 
- **tet_mesh_to_xml**: writes a tetrahedral mesh to an XML file.
- 
- **tetrahedron**: computes properties, including the centroid, circumsphere, dihedral angles, edge lengths, face angles, face areas, insphere, quality, solid angles, and volume, of a tetrahedron in 3D.
- 
- **tetrahedron_arbq_rule**: returns quadrature rules, with exactness up to total degree 15, over the interior of a tetrahedron in 3D, by Hong Xiao and Zydrunas Gimbutas.
- 
- **tetrahedron_exactness**: computes the monomial exactness of a quadrature rule over the interior of a tetrahedron in 3D.
- 
- **tetrahedron_felippa_rule**: returns a Felippa quadrature rule for approximating integrals over the interior of a tetrahedron in 3D.
- 
- **tetrahedron_grid**: computes a grid of points over the interior of a tetrahedron in 3D.
- 
- **tetrahedron_integrals**: returns the exact value of the integral of any monomial over the interior of the unit tetrahedron in 3D.
- 
- **tetrahedron_jaskowiec_rule**: returns quadrature rules, with exactness up to total degree 20, over the interior of a tetrahedron in 3D, by Jan Jaskowiec, Natarajan Sukumar.
- 
- **tetrahedron_keast_rule**: returns a Keast quadrature rule, with exactness between 0 and 8, over the interior of a tetrahedron in 3D.
- 
- **tetrahedron_monte_carlo**: uses the Monte Carlo method to estimate an integral over the interior of a general tetrahedron in 3D.
- 
- **tetrahedron_ncc_rule**: defines Newton-Cotes Closed (NCC) quadrature rules over the interior of a tetrahedron in 3D.
- 
- **tetrahedron_nco_rule**: defines Newton-Cotes Open (NCO) quadrature rules over the interior of a tetrahedron in 3D.
- 
- **tetrahedron_witherden_rule**: returns a symmetric Witherden quadrature rule for the tetrahedron, with exactness up to total degree 10.
- 
- **tetrahedron01_monte_carlo**: uses the Monte Carlo method to estimate an integral over the interior of the unit tetrahedron in 3D.
- 
- **three_body_ode**: simulates the behavior of three planets, constrained to lie in a plane, and moving under the influence of gravity, by Walter Gander and Jiri Hrebicek.
- 
- **tiler_2d**: demonstrates how to graphically tile a 2D box with a repeated pattern, using transfinite interpolation.
- 
- **tiler_3d**: demonstrates how to graphically tile a 3D box with a repeated pattern, using transfinite interpolation.
- 
- **timestamp**: prints the current YMDHMS date as a timestamp.
- 
- toeplitz, a Fortran90 code solves a variety of Toeplitz and circulant linear systems.
- 
- **toeplitz_cholesky**: computes the Cholesky factorization of a nonnegative definite symmetric Toeplitz matrix.
- 
- **toms097**: computes the distance between all pairs of nodes in a directed graph with weighted edges, using the Floyd algorithm.
- 
- **toms112**: determines whether a point is contained in a polygon, by Moshe Shimrat. This is a version of ACM TOMS algorithm 112.
- 
- **toms178**: optimizes a scalar functional of multiple variables using the Hooke-Jeeves method, by Arthur Kaupe. This is a version of ACM TOMS algorithm 178.
- 
- **toms179**: evaluates the modified Beta function, by Oliver Ludwig. This is a version of ACM TOMS algorithm 179.
- 
- **toms243**: evaluates the logarithm of a complex value, by David Collens. This is a version of ACM TOMS algorithm 243.
- 
- **toms291**: evaluates the logarithm of the Gamma function, by Malcolm Pike and David Hill. This is a version of ACM TOMS algorithm 291.
- 
- **toms419**: seeks all the zeroes of a polynomial with complex coefficients; this is commonly called cpoly(); this is a version of ACM TOMS algorithm 419, by Jenkins and Traub.
- 
- **toms443**: evaluates the Lambert W function, by Fritsch, Shafer and Crowley. This is a version of ACM TOMS algorithm 443.
- 
- **toms446**: manipulates Chebyshev series for interpolation and approximation; this is a version of ACM TOMS algorithm 446, by Roger Broucke.
- 
- **toms453**: determines the abscissas and weights for a Gaussian quadrature formula for the Bromwich integral; this is a version of ACM TOMS algorithm 453.
- 
- **toms462**: evaluates the upper right tail of the bivariate normal Probability Density Function (PDF); that is, the probability that normal variables X and Y with correlation R will satisfy H <= X and K <= Y; this is a version of ACM TOMS algorithm 462.
- 
- **toms493**: seeks the roots of a real polynomial, commonly called rpoly(); this is a version of ACM TOMS algorithm 493, by Michael Jenkins.
- 
- **toms515**: selects subsets of size K from a set of size N. This is a version of ACM TOMS Algorithm 515, by Bill Buckles, Matthew Lybanon.
- 
- **toms526**: interpolates scattered bivariate data. This is a version of ACM TOMS algorithm 526, by Hiroshi Akima;
- 
- **toms577**: evaluates the Carlson elliptic integral functions RC, RD, RF and RJ. This is a version of ACM TOMS algorithm 577;
- 
- **toms611**: seeks the minimizer of a scalar functional of multiple variables. This is a version of ACM TOMS algorithm 611, by David Gay.
- 
- **toms647**: evaluates Faure, Halton and Sobol Quasi Monte Carlo (QMC) sequences. This is a version of ACM TOMS algorithm 647.
- 
- **toms655**: computes the weights for interpolatory quadrature rules; this is commonly called IQPACK, by Sylvan Elhay and Jaroslav Kautsky. This is a version of ACM TOMS algorithm 655.
- 
- **toms659**: computes elements of the Sobol Quasi Monte Carlo (QMC) sequence; this is a version of ACM TOMS algorithm 659.
- 
- **toms660**: takes scattered 2D data and produces an interpolating function F(X,Y). This is a version of ACM TOMS algorithm 660, called qshep2d, by Robert Renka.
- 
- **toms661**: takes scattered 3D data and produces an interpolating function F(X,Y,Z). This is a version of ACM TOMS algorithm 661, called qshep3d, by Robert Renka.
- 
- **toms672**: generates an interpolatory quadrature rule of highest possible order, given preassigned abscissas. This can be used to generate Gauss-Kronrod and Gauss-Patterson quadrature rules. This is commonly called EXTEND. This is a version of ACM TOMS algorithm 672.
- 
- **toms708**: computes the incomplete Beta function ratio Ix(a,b).
- 
- **toms715**: evaluates special functions, including the Bessel I, J, K, and Y functions of order 0, of order 1, and of any real order, the Dawson integral, the error function, exponential integrals, the gamma function, the normal distribution function, the psi function. This is a version of ACM TOMS algorithm 715.
- 
- **toms726**: computes recursion coefficients for orthogonal polynomials, and the abscissa and weights for related quadrature rules. by Walter Gautschi. This is commonly called ORTHPOL. This is a version of ACM TOMS algorithm 726.
- 
- **toms738**: evaluates the Niederreiter Quasi Monte Carlo (QMC) sequence; this is a version of ACM TOMS algorithm 738;
- 
- **toms743**: evaluates the Lambert W function. This is a version of ACM TOMS algorithm 743, by Barry, Barry and Culligan-Hensley.
- 
- **toms757**: evaluates uncommon special functions, by Allan Mcleod; this is a version of ACM TOMS algorithm 757;
- 
- **toms792**: tests functions that interpolate scattered data in the plane; by Robert Renka; this is a version of ACM TOMS algorithm 792.
- 
- **toms886**: defines the Padua points for interpolation in a 2D region, including the rectangle, triangle, and ellipse, by Marco Caliari, Stefano de Marchi, Marco Vianello. This is a version of ACM TOMS algorithm 886.
- 
- **trapezoidal**: solves one or more ordinary differential equations (ODE) using the (implicit) trapezoidal method, and a version of fsolve() to handle the nonlinear equation.
- 
- **treepack**: defines, analyzes, and manipulates trees, a simple kind of graph with no circuits. Special cases include rooted and binary trees. Representations include adjacency, arc, Pruefer code, and parent. Operations include center, diameter, eccentricity, enumeration, generation one at a time, random selection, traversal.
- 
- **tri_surface_io**: reads and writes the 3D graphics information in a tri_surface file;
- 
- **triangle**: computes properties, including angles, area, centroid, circumcircle, edge lengths, incircle, orientation, orthocenter, and quality, of a triangle in 2D.
- 
- **triangle_analyze**: reads a triangle defined in a file, and computes angles, area, centroid, circumcircle, edge lengths, incircle, orientation, orthocenter, and quality.
- 
- **triangle_dunavant_rule**: defines Dunavant rules for quadrature over the interior of a triangle in 2D.
- 
- **triangle_exactness**: computes the monomial exactness quadrature rule over the interior of a triangle in 2D.
- 
- **triangle_fekete_rule**: defines a Fekete rule for interpolation or quadrature over the interior of a triangle in 2D.
- 
- **triangle_felippa_rule**: returns a Felippa quadrature rule for approximating integrals over the interior of a triangle in 2D.
- 
- **triangle_grid**: computes a grid of points over the interior of a triangle in 2D.
- 
- **triangle_histogram**: computes histograms of data over the interior of the unit triangle in 2D.
- 
- **triangle_integrals**: returns the exact value of the integral of any polynomial over the interior of an arbitrary triangle in 2D.
- 
- **triangle_interpolate**: shows how vertex data can be interpolated at any point in the interior of a triangle.
- 
- **triangle_io**: reads or writes some of the files created by Jonathan Shewchuk's triangle() program.
- 
- **triangle_lyness_rule**: returns a Lyness-Jespersen quadrature rule over the interior of a triangle in 2D.
- 
- **triangle_monte_carlo**: uses the Monte Carlo method to estimate an integral over the interior of a general triangle in 2D.
- 
- **triangle_ncc_rule**: defines Newton-Cotes Closed (NCC) quadrature rules over the interior of a triangle in 2D.
- 
- **triangle_nco_rule**: defines Newton-Cotes Open (NCO) quadrature rules over the interior of a triangle in 2D.
- 
- **triangle_svg**: uses Scalable Vector Graphics (SVG) to plot a triangle and any number of points, to illustrate quadrature rules and sampling techniques.
- 
- **triangle_symq_rule**: returns efficient symmetric quadrature rules, with exactness up to total degree 50, over the interior of an arbitrary triangle in 2D, by Hong Xiao and Zydrunas Gimbutas.
- 
- **triangle_to_fem**: reads the NODE and ELE files created by Jonathan Shewchuk's triangle() program to describe a triangular mesh, and writes a corresponding pair of node and element files in the 2D FEM format.
- 
- **triangle_to_medit**: reads the NODE and ELE files created by Jonathan Shewchuk's triangle() program to describe a triangular mesh, and writes a corresponding medit() MESH file.
- 
- **triangle_to_xml**: reads the NODE and ELE files created by Jonathan Shewchuk's triangle() program to describe a triangular mesh in 2D, and writes out a corresponding XML mesh file for use by dolfin() or fenics().
- 
- **triangle_twb_rule**: generates the points and weights of quadrature rules over the interior of a triangle in 2D, determined by Taylor, Wingate, and Bos.
- 
- **triangle_wandzura_rule**: returns Wandzura quadrature rules of exactness 5, 10, 15, 20, 25 or 30 over the interior of the triangle in 2D.
- 
- **triangle_witherden_rule**: returns a symmetric Witherden quadrature rule for the triangle, with exactness up to total degree 20.
- 
- **triangle01_integrals**: returns the integral of any monomial over the interior of the unit triangle in 2D.
- 
- **triangle01_monte_carlo**: uses the Monte Carlo method to estimate an integral over the interior of the unit triangle in 2D.
- 
- **triangulation**: computes the triangulation of points in the plane, and performs various operations using a triangulation, including searching a Delaunay triangulation to find which triangle contains a given point.
- 
- **triangulation_l2q**: reads information about a 3-node (linear) triangulation and creates data defining a corresponding 6-node (quadratic) triangulation;
- 
- **triangulation_mask**: reads a triangulation and calls a user-supplied routine to consider each triangle for deletion;
- 
- **triangulation_orient**: ensures that the triangles in an order 3 or order 6 triangulation have positive orientation;
- 
- **triangulation_plot**: plots the nodes and elements of a triangulation as a PostScript (PS) file;
- 
- **triangulation_q2l**: reads information about a 6-node triangulation and creates data defining a corresponding 3-node triangulation;
- 
- **triangulation_quad**: reads information about a triangulation and the value of a function at the nodes and estimates the integral of the function over the triangulated region.
- 
- **triangulation_quality**: reads information about a triangulation and computes various quality measures;
- 
- **triangulation_rcm**: reads files describing a triangulation of nodes in 2D, and applies the Reverse Cuthill McKee (RCM) algorithm to produce a renumbering of the triangulation with a reduced bandwidth.
- 
- **triangulation_svg**: creates an SVG image of a triangulation, which can be displayed by a web browser.
- 
- **triangulation_t3_to_t4**: reads information about a 3-node triangulation and creates data defining a corresponding 4-node triangulation (vertices + centroid);
- 
- **triangulation_triangle_neighbors**: reads data defining a triangulation, determines the neighboring triangles of each triangle, and writes that information to a file.
- 
- **truncated_normal**: works with the truncated normal distribution over [A,B], or [A,+oo) or (-oo,B], returning the probability density function (PDF), the cumulative density function (CDF), the inverse CDF, the mean, the variance, and sample values.
- 
- **truncated_normal_rule**: computes a quadrature rule for a normal probability density function (PDF), also called a Gaussian distribution, that has been truncated to [A,+oo), (-oo,B] or [A,B].
- 
- **tsp_brute**: reads a file of city-to-city distances and solves a (small!) traveling salesperson problem (TSP), using brute force.
- 
- **tsp_lau**: implements a heuristic algorithm for the solution of the traveling salesperson problem (TSP).
- 
- **two_body_ode**: sets up and solves ordinary differential equations (ODE) which simulate the behavior of two bodies, constrained to lie in a plane, moving under the influence of gravity, with one body much more massive than the other.
- 
- **ubvec**: demonstrates how unsigned binary vectors, strings of 0 and 1, represent nonnegative integers or subsets or other mathematical objects, for which various arithmetic and logical operations can be defined.
- 
- **unicycle**: considers permutations containing a single cycle, sometimes called cyclic permutations.
- 
- **uniform**: implements random number generators (RNG) for a variety of arithmetic types.
- 
- **van_der_corput**: computes elements of a 1D van der Corput Quasi Monte Carlo (QMC) sequence using a simple interface.
- 
- **vandermonde**: implements the Bjork-Pereyra algorithm for accurate solution of linear systems involving the Vandermonde matrix.
- 
- **vandermonde_approx_1d**: finds a polynomial approximant to data y(x) of a 1D argument by setting up and solving an overdetermined linear system for the polynomial coefficients involving the Vandermonde matrix.
- 
- **vandermonde_approx_2d**: finds a polynomial approximant p(x,y) to data z(x,y) of a 2D argument by setting up and solving an overdetermined linear system for the polynomial coefficients involving the Vandermonde matrix.
- 
- **vandermonde_interp_1d**: finds a polynomial interpolant to data y(x) of a 1D argument by setting up and solving a linear system for the polynomial coefficients involving the Vandermonde matrix, creating graphics files for processing by gnuplot().
- 
- **vandermonde_interp_2d**: finds a polynomial interpolant to data z(x,y) of a 2D argument by setting up and solving a linear system for the polynomial coefficients involving the Vandermonde matrix.
- 
- **vtk_io**: reads and writes some simple forms of VTK files.
- 
- **walker_sample**: efficiently samples a discrete probability vector using Walker sampling.
- 
- **walsh_transform**: implements the Walsh data transform.
- 
- **wathen_matrix**: compares storage schemes (full, banded, sparse triplet ) and solution strategies (Linpack full, Linpack banded, conjugate gradient) for linear systems involving the Wathen matrix, which can arise when solving a problem using the finite element method (FEM).
- 
- **wave_mpi**: uses the finite difference method (FDM) to estimate a solution to the wave equation, using the Message Passing Interface (MPI) for parallel execution.
- 
- **wavelet**: does some simple calculations with wavelet transforms;
- 
- **wedge_exactness**: investigates the polynomial exactness of a quadrature rule over the interior of the unit wedge in 3D.
- 
- **wedge_felippa_rule**: returns a Felippa quadrature rule for approximating integrals over the interior of the unit wedge in 3D.
- 
- **wedge_grid**: computes a grid of points over the interior of the unit wedge in 3D.
- 
- **wedge_integrals**: returns the exact value of the integral of any monomial over the interior of the unit wedge in 3D.
- 
- **wedge_monte_carlo**: uses the Monte Carlo method to estimate an integral over the interior of the unit wedge in 3D.
- 
- **weekday**: determines the day of the week corresponding to a given date, such as 14 October 1066, Julian calendar, which was a Saturday.
- 
- **wishart_matrix**: produces sample matrices from the Wishart or Bartlett distributions, useful for sampling random covariance matrices.
- 
- **wordsnake**: tries to find a good solution to the "Wordsnake Puzzle", in which a list of words is reordered, trying to maximize the overlap of successive words.
- 
- **wtime**: returns a reading of the wall clock time in seconds.
- 
- **xerror**: reports and handles errors detected during execution.
- 
- **xy_io**: reads and writes simple graphics files in the XY, XYL and XYF formats.
- 
- **xyz_io**: reads and writes simple graphics files in the XYZ, XYZL and XYZF formats.
- 
- **xyz_to_pdb**: reads an XYZ file containing a list of spatial coordinates, and writes a Protein Data Bank (PDB) file containing ATOM records with the given coordinates.
- 
- **zero_brent**: seeks a solution of a scalar nonlinear equation f(x)=0, by Richard Brent.
- 
- **zero_chandrupatla**: finds a zero of a scalar function of a scalar variable, starting from a change of sign interval, using the Chandrupatla method, which can converge faster than bisection, regula falsi, or Brent's method, by Tirupathi Chandrapatla.
- 
- **zero_itp**: finds a zero of a scalar function of a scalar variable, starting from a change of sign interval, using the Interpolate/Truncate/Project (ITP) method, which has faster convergence than the bisection method.
- 
- **zero_laguerre**: uses Laguerre's method to find the zero of a function. The method needs first and second derivative information. The method almost always works when the function is a polynomial.
- 
- **zero_muller**: seeks a root of a nonlinear equation using the Muller method, with complex arithmetic.
- 
- **zero_rc**: seeks a solution of a scalar nonlinear equation f(x)=0, using reverse communication (RC), by Richard Brent.
- 
- **zoomin**: implements many procedures for finding the zero of a scalar nonlinear function.
- 
