22 January 2020   1:20:56.182 PM

SUBSET_TEST
  FORTRAN90 version
  Test SUBSET.

ASM_ENUM_TEST
  ASM_ENUM returns the number of alternating sign
  matrices of a given order.

   0         1
   1         1
   2         2
   3         7
   4        42
   5       429
   6      7436
   7    218348

ASM_TRIANGLE_TEST
  ASM_TRIANGLE returns a row of the alternating sign
  matrix triangle.

   0         1
   1         1       1
   2         2       3       2
   3         7      14      14       7
   4        42     105     135     105      42
   5       429    1287    2002    2002    1287     429
   6      7436   26026   47320   56784   47320   26026    7436
   7    218348  873392 1813968 2519400 2519400 1813968  873392  218348

BELL_TEST
  BELL computes Bell numbers.

  N  exact C(I)  computed C(I)

     0         1         1
     1         1         1
     2         2         2
     3         5         5
     4        15        15
     5        52        52
     6       203       203
     7       877       877
     8      4140      4140
     9     21147     21147
    10    115975    115975

CATALAN_TEST
  CATALAN computes Catalan numbers.

  N  exact C(I)  computed C(I)

     0       1       1
     1       1       1
     2       2       2
     3       5       5
     4      14      14
     5      42      42
     6     132     132
     7     429     429
     8    1430    1430
     9    4862    4862
    10   16796   16796

CATALAN_ROW_NEXT_TEST
  CATALAN_ROW_NEXT computes a row of Catalan's triangle.

  First, compute row 7:
   7       1     7    27    75   165   297   429   429

  Now compute rows one at a time:

   0       1
   1       1     1
   2       1     2     2
   3       1     3     5     5
   4       1     4     9    14    14
   5       1     5    14    28    42    42
   6       1     6    20    48    90   132   132
   7       1     7    27    75   165   297   429   429
   8       1     8    35   110   275   572  1001  1430  1430
   9       1     9    44   154   429  1001  2002  3432  4862  4862
  10       1    10    54   208   637  1638  3640  7072 11934 16796 16796

CFRAC_TO_RAT_TEST
  CFRAC_TO_RAT continued fraction => fraction.

  Regular fraction is     4096 /    15625

  Continued fraction coefficients:

       1         0
       2         3
       3         1
       4         4
       5         2
       6         1
       7         1
       8        11
       9        13

  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.

  I, P(I), Q(I), P(I)/Q(I)

    1       0       1   0.00000    
    2       1       3  0.333333    
    3       1       4  0.250000    
    4       5      19  0.263158    
    5      11      42  0.261905    
    6      16      61  0.262295    
    7      27     103  0.262136    
    8     313    1194  0.262144    
    9    4096   15625  0.262144    

CFRAC_TO_RFRAC_TEST
  CFRAC_TO_RFRAC: continued fraction to ratio.

  Rational polynomial fraction coefficients:

  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000

  Continued fraction coefficients:

       1   1.00000    
       2  0.500000    
       3   1.33333    
       4 -0.500000    
       5  -1.50000    
       6   2.00000    

  Recovered rational polynomial:

  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000

CHANGE_GREEDY_TEST
  CHANGE_GREEDY makes change using the biggest
  coins first.

  The total for which change is to be made:       73

  The available coins are:

         1
         5
        10
        25
        50
       100

         6      5  3  3  1  1  1
        73     50 10 10  1  1  1

CHANGE_NEXT_TEST
  CHANGE_NEXT displays the next possible way to make
  change for a given total

  The total for which change is to be made:       50


  The available coins are:

         1
         5
        10
        25
        50
       100

  1:
   50

  2:
   25 25

  3:
   25 10 10  5

  4:
   25 10 10  1  1  1  1  1

  5:
   25 10  5  5  5

  6:
   25 10  5  5  1  1  1  1  1

  7:
   25 10  5  1  1  1  1  1  1  1  1  1  1

  8:
   25 10  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1

  9:
   25  5  5  5  5  5

 10:
   25  5  5  5  5  1  1  1  1  1

CHINESE_CHECK_TEST
  CHINESE_CHECK checks a set of moduluses for suitability
  with the Chinese Remainder representation.

  Modulus set #1:

       1         1
       2         3
       3         8
       4        25
  Error flag =    0

  Modulus set #2:

       1         1
       2         3
       3        -8
       4        25
  Error flag =    1

  Modulus set #3:

       1         1
       2         3
       3         1
       4        25
  Error flag =    2

  Modulus set #4:

       1         1
       2         3
       3         8
       4        24
  Error flag =    3

CHINESE_TO_I4_TEST
  CHINESE_TO_I4 computes an integer with the given
  Chinese Remainder representation.

  The moduli:

       1         3
       2         4
       3         5
       4         7

  The number being analyzed is       37

  The remainders:

       1         1
       2         1
       3         2
       4         2

  The reconstructed number is       37

  The remainders of the reconstructed number are:

       1         1
       2         1
       3         2
       4         2

COMB_NEXT_TEST
  COMB_NEXT produces combinations.

  Combinations of size K =        1

    1
    2
    3
    4
    5

  Combinations of size K =        2

    1  2
    1  3
    1  4
    1  5
    2  3
    2  4
    2  5
    3  4
    3  5
    4  5

  Combinations of size K =        3

    1  2  3
    1  2  4
    1  2  5
    1  3  4
    1  3  5
    1  4  5
    2  3  4
    2  3  5
    2  4  5
    3  4  5

  Combinations of size K =        4

    1  2  3  4
    1  2  3  5
    1  2  4  5
    1  3  4  5
    2  3  4  5

  Combinations of size K =        5

    1  2  3  4  5

COMB_ROW_NEXT_TEST
  COMB_ROW computes a row of Pascal's triangle.

   0      1
   1      1    1
   2      1    2    1
   3      1    3    3    1
   4      1    4    6    4    1
   5      1    5   10   10    5    1
   6      1    6   15   20   15    6    1
   7      1    7   21   35   35   21    7    1
   8      1    8   28   56   70   56   28    8    1
   9      1    9   36   84  126  126   84   36    9    1
  10      1   10   45  120  210  252  210  120   45   10    1

COMB_UNRANK_TEST
  COMB_UNRANK returns a combination of N things
  out of M, given the lexicographic rank.

  The total set size is M =       10
  The subset size is N =           5
  The number of combinations of N out of M is      252

   Rank	  Combination

    1      1   2   3   4   5
    2      1   2   3   4   6
    3      1   2   3   4   7
    6      1   2   3   4  10
    7      1   2   3   5   6
    8      1   2   3   5   7
  250      5   6   8   9  10
  251      5   7   8   9  10
  252      6   7   8   9  10


COMP_ENUM_TEST
  COMP_ENUM counts compositions;

       1       1       1       1       1       1       1       1       1       1
       1       2       3       4       5       6       7       8       9      10
       1       3       6      10      15      21      28      36      45      55
       1       4      10      20      35      56      84     120     165     220
       1       5      15      35      70     126     210     330     495     715
       1       6      21      56     126     252     462     792    1287    2002
       1       7      28      84     210     462     924    1716    3003    5005
       1       8      36     120     330     792    1716    3432    6435   11440
       1       9      45     165     495    1287    3003    6435   12870   24310
       1      10      55     220     715    2002    5005   11440   24310   48620
       1      11      66     286    1001    3003    8008   19448   43758   92378

COMP_NEXT_TEST
  COMP_NEXT generates compositions.

  Seeking all compositions of N =        6
  using        3 parts.
     1     6   0   0
     2     5   1   0
     3     4   2   0
     4     3   3   0
     5     2   4   0
     6     1   5   0
     7     0   6   0
     8     5   0   1
     9     4   1   1
    10     3   2   1
    11     2   3   1
    12     1   4   1
    13     0   5   1
    14     4   0   2
    15     3   1   2
    16     2   2   2
    17     1   3   2
    18     0   4   2
    19     3   0   3
    20     2   1   3
    21     1   2   3
    22     0   3   3
    23     2   0   4
    24     1   1   4
    25     0   2   4
    26     1   0   5
    27     0   1   5
    28     0   0   6

COMP_NEXT_GRLEX_TEST
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_NEXT_GRLEX determines the next COMP in
  graded lexicographic (grlex) order.

  Rank:     NC       COMP    
  ----:     --   ------------
     1:      0 =  0 +  0 +  0
  ----:     --   ------------
     2:      1 =  0 +  0 +  1
     3:      1 =  0 +  1 +  0
     4:      1 =  1 +  0 +  0
  ----:     --   ------------
     5:      2 =  0 +  0 +  2
     6:      2 =  0 +  1 +  1
     7:      2 =  0 +  2 +  0
     8:      2 =  1 +  0 +  1
     9:      2 =  1 +  1 +  0
    10:      2 =  2 +  0 +  0
  ----:     --   ------------
    11:      3 =  0 +  0 +  3
    12:      3 =  0 +  1 +  2
    13:      3 =  0 +  2 +  1
    14:      3 =  0 +  3 +  0
    15:      3 =  1 +  0 +  2
    16:      3 =  1 +  1 +  1
    17:      3 =  1 +  2 +  0
    18:      3 =  2 +  0 +  1
    19:      3 =  2 +  1 +  0
    20:      3 =  3 +  0 +  0
  ----:     --   ------------
    21:      4 =  0 +  0 +  4
    22:      4 =  0 +  1 +  3
    23:      4 =  0 +  2 +  2
    24:      4 =  0 +  3 +  1
    25:      4 =  0 +  4 +  0
    26:      4 =  1 +  0 +  3
    27:      4 =  1 +  1 +  2
    28:      4 =  1 +  2 +  1
    29:      4 =  1 +  3 +  0
    30:      4 =  2 +  0 +  2
    31:      4 =  2 +  1 +  1
    32:      4 =  2 +  2 +  0
    33:      4 =  3 +  0 +  1
    34:      4 =  3 +  1 +  0
    35:      4 =  4 +  0 +  0
  ----:     --   ------------
    36:      5 =  0 +  0 +  5
    37:      5 =  0 +  1 +  4
    38:      5 =  0 +  2 +  3
    39:      5 =  0 +  3 +  2
    40:      5 =  0 +  4 +  1
    41:      5 =  0 +  5 +  0
    42:      5 =  1 +  0 +  4
    43:      5 =  1 +  1 +  3
    44:      5 =  1 +  2 +  2
    45:      5 =  1 +  3 +  1
    46:      5 =  1 +  4 +  0
    47:      5 =  2 +  0 +  3
    48:      5 =  2 +  1 +  2
    49:      5 =  2 +  2 +  1
    50:      5 =  2 +  3 +  0
    51:      5 =  3 +  0 +  2
    52:      5 =  3 +  1 +  1
    53:      5 =  3 +  2 +  0
    54:      5 =  4 +  0 +  1
    55:      5 =  4 +  1 +  0
    56:      5 =  5 +  0 +  0
  ----:     --   ------------
    57:      6 =  0 +  0 +  6
    58:      6 =  0 +  1 +  5
    59:      6 =  0 +  2 +  4
    60:      6 =  0 +  3 +  3
    61:      6 =  0 +  4 +  2
    62:      6 =  0 +  5 +  1
    63:      6 =  0 +  6 +  0
    64:      6 =  1 +  0 +  5
    65:      6 =  1 +  1 +  4
    66:      6 =  1 +  2 +  3
    67:      6 =  1 +  3 +  2
    68:      6 =  1 +  4 +  1
    69:      6 =  1 +  5 +  0
    70:      6 =  2 +  0 +  4
    71:      6 =  2 +  1 +  3

COMP_RANDOM_TEST
  COMP_RANDOM generates random compositions.

  Seeking random compositions of N =       10
  using        5 parts.

     0   4   1   0   5
     1   4   2   0   3
     2   0   2   6   0
     2   2   3   0   3
     1   3   1   5   0

COMP_RANDOM_GRLEX_TEST
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_RANDOM_GRLEX selects a random COMP in
  graded lexicographic (grlex) order between
  indices RANK1 and RANK2.

    28:      4 =  1 +  2 +  1
    59:      6 =  0 +  2 +  4
    54:      5 =  4 +  0 +  1
    43:      5 =  1 +  1 +  3
    37:      5 =  0 +  1 +  4

COMP_RANK_GRLEX_TEST
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_RANK_GRLEX determines the rank of a COMP
  from its parts.

        Actual  Inferred
  Test    Rank      Rank

     1      28        28
     2      59        59
     3      54        54
     4      43        43
     5      37        37

COMP_TO_KSUB_TEST
  COMP_TO_KSUB returns the K subset corresponding to a composition.

  COMP:   0   4   1   0   5
  KSUB:   1   6   8   9
  COMP:   0   4   1   0   5

  COMP:   1   4   2   0   3
  KSUB:   2   7  10  11
  COMP:   1   4   2   0   3

  COMP:   2   0   2   6   0
  KSUB:   3   4   7  14
  COMP:   2   0   2   6   0

  COMP:   2   2   3   0   3
  KSUB:   3   6  10  11
  COMP:   2   2   3   0   3

  COMP:   1   3   1   5   0
  KSUB:   2   6   8  14
  COMP:   1   3   1   5   0

COMP_UNRANK_GRLEX_TEST
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_UNRANK_GRLEX determines the parts
  of a COMP from its rank.

  Rank: ->  NC       COMP
  ----:     --   ------------
     1:      0 =  0 +  0 +  0
  ----:     --   ------------
     2:      1 =  0 +  0 +  1
     3:      1 =  0 +  1 +  0
     4:      1 =  1 +  0 +  0
  ----:     --   ------------
     5:      2 =  0 +  0 +  2
     6:      2 =  0 +  1 +  1
     7:      2 =  0 +  2 +  0
     8:      2 =  1 +  0 +  1
     9:      2 =  1 +  1 +  0
    10:      2 =  2 +  0 +  0
  ----:     --   ------------
    11:      3 =  0 +  0 +  3
    12:      3 =  0 +  1 +  2
    13:      3 =  0 +  2 +  1
    14:      3 =  0 +  3 +  0
    15:      3 =  1 +  0 +  2
    16:      3 =  1 +  1 +  1
    17:      3 =  1 +  2 +  0
    18:      3 =  2 +  0 +  1
    19:      3 =  2 +  1 +  0
    20:      3 =  3 +  0 +  0
  ----:     --   ------------
    21:      4 =  0 +  0 +  4
    22:      4 =  0 +  1 +  3
    23:      4 =  0 +  2 +  2
    24:      4 =  0 +  3 +  1
    25:      4 =  0 +  4 +  0
    26:      4 =  1 +  0 +  3
    27:      4 =  1 +  1 +  2
    28:      4 =  1 +  2 +  1
    29:      4 =  1 +  3 +  0
    30:      4 =  2 +  0 +  2
    31:      4 =  2 +  1 +  1
    32:      4 =  2 +  2 +  0
    33:      4 =  3 +  0 +  1
    34:      4 =  3 +  1 +  0
    35:      4 =  4 +  0 +  0
  ----:     --   ------------
    36:      5 =  0 +  0 +  5
    37:      5 =  0 +  1 +  4
    38:      5 =  0 +  2 +  3
    39:      5 =  0 +  3 +  2
    40:      5 =  0 +  4 +  1
    41:      5 =  0 +  5 +  0
    42:      5 =  1 +  0 +  4
    43:      5 =  1 +  1 +  3
    44:      5 =  1 +  2 +  2
    45:      5 =  1 +  3 +  1
    46:      5 =  1 +  4 +  0
    47:      5 =  2 +  0 +  3
    48:      5 =  2 +  1 +  2
    49:      5 =  2 +  2 +  1
    50:      5 =  2 +  3 +  0
    51:      5 =  3 +  0 +  2
    52:      5 =  3 +  1 +  1
    53:      5 =  3 +  2 +  0
    54:      5 =  4 +  0 +  1
    55:      5 =  4 +  1 +  0
    56:      5 =  5 +  0 +  0
  ----:     --   ------------
    57:      6 =  0 +  0 +  6
    58:      6 =  0 +  1 +  5
    59:      6 =  0 +  2 +  4
    60:      6 =  0 +  3 +  3
    61:      6 =  0 +  4 +  2
    62:      6 =  0 +  5 +  1
    63:      6 =  0 +  6 +  0
    64:      6 =  1 +  0 +  5
    65:      6 =  1 +  1 +  4
    66:      6 =  1 +  2 +  3
    67:      6 =  1 +  3 +  2
    68:      6 =  1 +  4 +  1
    69:      6 =  1 +  5 +  0
    70:      6 =  2 +  0 +  4
    71:      6 =  2 +  1 +  3

COMPNZ_ENUM_TEST
  COMPNZ_ENUM enumerates compositions with nonzero parts.

  Seeking all compositions of N =        6
  using        3 nonzero parts.

  The number of these compositions is       10

COMPNZ_NEXT_TEST
  COMPNZ_NEXT generates compositions with nonzero parts.

  Seeking all compositions of N =        6
  using        3 nonzero parts.
     1     4   1   1
     2     3   2   1
     3     2   3   1
     4     1   4   1
     5     3   1   2
     6     2   2   2
     7     1   3   2
     8     2   1   3
     9     1   2   3
    10     1   1   4

COMPNZ_RANDOM_TEST
  COMPNZ_RANDOM generates random compositions
  with nonzero parts.

  Seeking random compositions of N =       10
  using        5 nonzero parts.

     1   4   1   1   3
     1   1   2   5   1
     2   1   1   3   3
     1   1   2   3   3
     4   2   1   2   1

COMPNZ_TO_KSUB_TEST
  COMPNZ_TO_KSUB returns the K subset corresponding 
  to a nonzero composition.

  COMPNZ:   1   4   1   1   3
  KSUB:     1   5   6   7
  COMPNZ:   1   4   1   1   3

  COMPNZ:   1   1   2   5   1
  KSUB:     1   2   4   9
  COMPNZ:   1   1   2   5   1

  COMPNZ:   2   1   1   3   3
  KSUB:     2   3   4   7
  COMPNZ:   2   1   1   3   3

  COMPNZ:   1   1   2   3   3
  KSUB:     1   2   4   7
  COMPNZ:   1   1   2   3   3

  COMPNZ:   4   2   1   2   1
  KSUB:     4   6   7   9
  COMPNZ:   4   2   1   2   1

CONGRUENCE_TEST
  CONGRUENCE solves a congruence equation:
    A * X = C mod ( B )

   I        A         B         C         X     Mod ( A*X-C,B)

   1        1027       712         7       269         0
   2        1027       712        -7       443         0
   3        1027      -712         7     -1155         0
   4        1027      -712        -7       443         0
   5       -1027       712         7       443         0
   6       -1027       712        -7       269         0
   7       -1027      -712         7       443         0
   8       -1027      -712        -7     -1155         0
   9           6         8        50         7         0
  10           0         0         0         0         0
  11           0         1         0         0         0
  12           0         1         1         0         0
  13           1         0         0         0         0
  14           1         0         1         1         0
  15           1         1         0         1         0
  16        1024    -15625     11529    -15629         0
  17           0         0         1 Error code =          1
  18           0         3        11 Error code =          2
  19           5         0        19 Error code =          3
  20           2         4         7 Error code =          4
  21           7        19         1        11         0

COUNT_POSE_RANDOM_TEST
  COUNT_POSE_RANDOM poses a random problem for 
  the game "The Count is Good".

  Problem #       1

    The goal number:

           296

    The available numbers are 

         4   5   6   7   8  10

  Problem #       2

    The goal number:

           504

    The available numbers are 

         1   4   6   7   8  25

  Problem #       3

    The goal number:

           106

    The available numbers are 

         1   3   4   6  50  75

  Problem #       4

    The goal number:

           785

    The available numbers are 

         1   2   6   7   9  75

  Problem #       5

    The goal number:

           739

    The available numbers are 

         1   4   8  10  25  75

DEBRUIJN_TEST
  DEBRUIJN computes a de Bruijn string.

  The alphabet size is M =        2
  The string length is N =        3

    21222111

  The alphabet size is M =        3
  The string length is N =        3

    212221132131232231332333111

  The alphabet size is M =        2
  The string length is N =        4

    2121122122221111

DEC_ADD_TEST
  DEC_ADD adds two decimals.

  Number of decimal places is        3

  A = 12.8
  B = 4.38
  C = 17.2

DEC_DIV_TEST
  DEC_DIV divides two decimals.

  Number of decimal places is        3

  A = 52.3
  B = 13400
  C = 0.0039

DEC_MUL_TEST
  DEC_MUL multiplies two decimals.

  Number of decimal places is        2

  A = 0.0014
  B = 1600
  C = 2.2

DEC_ROUND_TEST
  DEC_ROUND "rounds" a decimal to a number of digits.

           -----Before-------  -----After--------
  Digits   Mantissa  Exponent  Mantissa  Exponent

         1     523      -1           5       1
         2     523      -1          52       0
         3     523      -1         523      -1
         4     523      -1         523      -1
         2    6340       2          63       4
         3    6340       2         634       3
         4    6340       2         634       3

DEC_TO_R8_TEST
  DEC_TO_R8 converts a decimal to a real number.

  The number of decimal digits is   5

     R   =>  A * 10^B  =>  R2

   -5.631634    -56316        -4   -5.631600
    9.126352     91264        -4    9.126400
    6.590185     65902        -4    6.590200
    1.233909     12339        -4    1.233900
   -1.693858    -16939        -4   -1.693900
   -8.677625    -86776        -4   -8.677600
   -4.848444    -48484        -4   -4.848400
   -7.800864    -78009        -4   -7.800900
   -9.123420    -91234        -4   -9.123400
    2.679314     26793        -4    2.679300

DEC_TO_RAT_TEST
  DEC_TO_RAT decimal => fraction.

  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.

  Then convert to decimal, and the equivalent real.

  Then convert back to rational and the equivalent real.

   -0.588297=        -563/         957
   -0.588297=  -588296760*10^          -9
   -0.588297=   -14707419/    25000000

    1.172598=         659/         562
    1.172598=  1172597864*10^          -9
    1.172598=   146574733/   125000000

   -2.522388=        -169/          67
   -2.522388=  -252238805*10^          -8
   -2.522388=   -50447761/    20000000

   -4.409091=        -485/         110
   -4.409091=  -440909090*10^          -8
   -4.409091=   -44090909/    10000000

   -1.440063=        -913/         634
   -1.440063= -1440063091*10^          -9
   -1.440063= -1440063091/  1000000000

   -1.948889=        -877/         450
   -1.948889= -1948888888*10^          -9
   -1.948889=  -243611111/   125000000

   -0.260927=        -197/         755
   -0.260927=  -260927152*10^          -9
   -0.260927=   -16307947/    62500000

  297.500000=         595/           2
  297.500000=        2975*10^          -1
  297.500000=         595/           2

    2.264957=         795/         351
    2.264957=   226495726*10^          -8
    2.264957=   113247863/    50000000

  -57.928571=        -811/          14
  -57.928571=  -579285714*10^          -7
  -57.928571=  -289642857/     5000000

DEC_TO_S_TEST
  DEC_TO_S prints a decimal value.

  Mantissa  Exponent  String

       523        -1  52.3
       134         2  13400
      -134         2  -13400
         0        10  0
    123456        -8  0.00123456
    123456        -7  0.0123456
    123456        -6  0.123456
    123456        -5  1.23456
    123456        -4  12.3456
    123456        -3  123.456
    123456        -2  1234.56
    123456        -1  12345.6
    123456         0  123456
    123456         1  1234560
    123456         2  12345600
    123456         3  123456000

DEC_WIDTH_TEST
  DEC_WIDTH determines the "width" of a decimal.

  Mantissa  Exponent  Width

       523        -1         4
       134         2         5
      -134         2         6
         0        10         1
    123456        -8        10
    123456        -7         9
    123456        -6         8
    123456        -5         7
    123456        -4         7
    123456        -3         7
    123456        -2         7
    123456        -1         7
    123456         0         6
    123456         1         7
    123456         2         8
    123456         3         9

DECMAT_DET_TEST
  DECMAT_DET: determinant of a decimal matrix.


  The 123/456/789 matrix:

       1   2   3
       4   5   6
       7   8   9

  Determinant of the 123/456/789 matrix
         0 * 10**        0

  The Hilbert matrix:

             0.5   0.3333333        0.25         0.2
       0.3333333        0.25         0.2   0.1666667
            0.25         0.2   0.1666667   0.1428571
             0.2   0.1666667   0.1428571       0.125

  Determinant of the Hilbert matrix:
         5 * 10 **       -9

  The -1,2,-1 matrix:

        2   -1    0
       -1    2   -1
        0   -1    2

  Determinant of the -1,2,-1 matrix:
         4 * 10 **        0

DECMAT_PRINT_TEST
  DECMAT_PRINT prints a decimal matrix.

  The Hilbert matrix:

             0.5   0.3333333        0.25
       0.3333333        0.25         0.2
            0.25         0.2   0.1666667
             0.2   0.1666667   0.1428571

DERANGE_ENUM_TEST
  DERANGE_ENUM counts derangements;

  N    # of derangements

         0           1
         1           0
         2           1
         3           2
         4           9
         5          44
         6         265
         7        1854
         8       14833
         9      133496
        10     1334961

DERANGE_ENUM2_TEST
  DERANGE_ENUM2 counts derangements.

  N    # of derangements

         0           1
         1           0
         2           1
         3           2
         4           9
         5          44
         6         265
         7        1854
         8       14833
         9      133496
        10     1334961

DERANGE_ENUM3_TEST
  DERANGE_ENUM3 counts derangements.

  N    # of derangements

         0           1
         1           0
         2           1
         3           2
         4           9
         5          44
         6         265
         7        1854
         8       14833
         9      133496
        10     1334961

DERANGE1_BACK_NEXT_TEST
  DERANGE1_BACK_NEXT generates derangements
  using backtracking.

  Here, we seek all derangments of order N =        5

     1       5   4   2   3   1
     2       5   4   2   1   3
     3       5   4   1   3   2
     4       5   4   1   2   3
     5       5   3   4   2   1
     6       5   3   4   1   2
     7       5   3   2   1   4
     8       5   3   1   2   4
     9       5   1   4   3   2
    10       5   1   4   2   3
    11       5   1   2   3   4
    12       4   5   2   3   1
    13       4   5   2   1   3
    14       4   5   1   3   2
    15       4   5   1   2   3
    16       4   3   5   2   1
    17       4   3   5   1   2
    18       4   3   2   5   1
    19       4   3   1   5   2
    20       4   1   5   3   2
    21       4   1   5   2   3
    22       4   1   2   5   3
    23       3   5   4   2   1
    24       3   5   4   1   2
    25       3   5   2   1   4
    26       3   5   1   2   4
    27       3   4   5   2   1
    28       3   4   5   1   2
    29       3   4   2   5   1
    30       3   4   1   5   2
    31       3   1   5   2   4
    32       3   1   4   5   2
    33       3   1   2   5   4
    34       2   5   4   3   1
    35       2   5   4   1   3
    36       2   5   1   3   4
    37       2   4   5   3   1
    38       2   4   5   1   3
    39       2   4   1   5   3
    40       2   3   5   1   4
    41       2   3   4   5   1
    42       2   3   1   5   4
    43       2   1   5   3   4
    44       2   1   4   5   3

DERANGE1_CHECK_TEST
  DERANGE1_CHECK_checks whether a vector of N objects
  represents a derangement of (1,...,N).
 
  Potential derangement:
           2           3           4           5           1
  CHECK = T
 
  Potential derangement:
           2           5           3           1           4
  CHECK = F
 
  Potential derangement:
           2           3           4           1           4
  CHECK = F
 
  Potential derangement:
           0           3           4           5           1
  CHECK = F
 
  Potential derangement:
           1           4           9           2           3
  CHECK = F

DERANGE1_WEED_NEXT_TEST
  DERANGE1_WEED_NEXT generates derangements of (1,...,N)
  by generating ALL permutations, and "weeding out"
  the ones that are not derangements.

  Here, we seek all derangements of order N =        5

     1       2   1   4   5   3
     2       2   1   5   3   4
     3       2   3   1   5   4
     4       2   3   4   5   1
     5       2   3   5   1   4
     6       2   4   1   5   3
     7       2   4   5   1   3
     8       2   4   5   3   1
     9       2   5   1   3   4
    10       2   5   4   1   3
    11       2   5   4   3   1
    12       3   1   2   5   4
    13       3   1   4   5   2
    14       3   1   5   2   4
    15       3   4   1   5   2
    16       3   4   2   5   1
    17       3   4   5   1   2
    18       3   4   5   2   1
    19       3   5   1   2   4
    20       3   5   2   1   4
    21       3   5   4   1   2
    22       3   5   4   2   1
    23       4   1   2   5   3
    24       4   1   5   2   3
    25       4   1   5   3   2
    26       4   3   1   5   2
    27       4   3   2   5   1
    28       4   3   5   1   2
    29       4   3   5   2   1
    30       4   5   1   2   3
    31       4   5   1   3   2
    32       4   5   2   1   3
    33       4   5   2   3   1
    34       5   1   2   3   4
    35       5   1   4   2   3
    36       5   1   4   3   2
    37       5   3   1   2   4
    38       5   3   2   1   4
    39       5   3   4   1   2
    40       5   3   4   2   1
    41       5   4   1   2   3
    42       5   4   1   3   2
    43       5   4   2   1   3
    44       5   4   2   3   1

DIGRAPH_ARC_EULER_TEST
  DIGRAPH_ARC_EULER finds an Euler circuit of a digraph.

  The arc list of the digraph:

       1           2       5
       2           1       4
       3           2       3
       4           1       2
       5           3       1
       6           5       1
       7           4       2

  The edge list of the Euler circuit:

       1         6
       2         4
       3         3
       4         5
       5         2
       6         7
       7         1

  The node list of the Euler circuit:

    I  Edge  Node

         1       6       1
         2       4       2
         3       3       3
         4       5       1
         5       2       4
         6       7       2
         7       1       5

DIGRAPH_ARC_PRINT_TEST
  DIGRAPH_ARC_PRINT prints a digraph.

  The arc list of the digraph:

       1           2       5
       2           1       4
       3           2       3
       4           1       2
       5           3       1
       6           5       1
       7           4       2

DIOPHANTINE_TEST
  DIOPHANTINE solves a Diophantine equation:
    A * X + B * Y = C

        A         B         C         X     Y     Error

        1027       712         7       269      -388         0
        1027       712        -7      -269       388         0
        1027      -712         7       269       388         0
        1027      -712        -7      -269      -388         0
       -1027       712         7      -269      -388         0
       -1027       712        -7       269       388         0
       -1027      -712         7      -269       388         0
       -1027      -712        -7       269      -388         0
           6         8        50         3         4         0
           0         0         0         0         0         0
           0         1         0         0         0         0
           0         1         1         0         1         0
           1         0         0         0         0         0
           1         0         1         1         0         0
           1         1         0         1        -1         0
        1024    -15625     11529        -4        -1         0
           0         0         1 Error code =          1
           0         3        11 Error code =          2
           5         0        19 Error code =          3
           2         4         7 Error code =          4

DIOPHANTINE_SOLUTION_MINIMIZE_TEST
  DIOPHANTINE_SOLUTION_MINIMIZE computes a minimal
  Euclidean norm solution of a Diophantine equation:
    A * X + B * Y = C

  Coefficients:
    A =         4096
    B =       -15625
    C =        46116
  Solution:
    X =    665499996
    Y =    174456828
  Residual R = A * X + B * Y - C:
    R =            0

  The minimized solution:
    X =           -4
    Y =           -4
  Residual R = A * X + B * Y - C:
    R =            0

  The minimal positive solution:
    X =        15621
    Y =         4092
  Residual R = A * X + B * Y - C:
    R =            0

DVEC_ADD_TEST
  DVEC_ADD adds decimal vectors representing integers;

        I        J        K = I + J


       -57        92
  Directly:                 35
            DVEC_ADD        35

        66        12
  Directly:                 78
            DVEC_ADD        78

       -17       -87
  Directly:               -104
            DVEC_ADD      -104

       -49       -78
  Directly:               -127
            DVEC_ADD      -127

       -92        27
  Directly:                -65
            DVEC_ADD       -65

       -88       -10
  Directly:                -98
            DVEC_ADD       -98

       -20        51
  Directly:                 31
            DVEC_ADD        31

        60      -100
  Directly:                -40
            DVEC_ADD       -40

        80       -30
  Directly:                 50
            DVEC_ADD        50

       -81       -98
  Directly:               -179
            DVEC_ADD      -179

DVEC_COMPLEMENTX_TEST
  DVEC_COMPLEMENTX returns the ten's complement
  of a (signed) decimal vector;


  I =        -57
  J =         57

  -999999943

  +000000057

  I =         92
  J =        -92

  +000000092

  -999999908

  I =         66
  J =        -66

  +000000066

  -999999934

  I =         12
  J =        -12

  +000000012

  -999999988

  I =        -17
  J =         17

  -999999983

  +000000017

DVEC_MUL_TEST
  DVEC_MUL multiplies decimal vectors 
  representing integers;

        I        J        K = I * J


      -563       913
  Directly:            -514019
  DVEC_MUL             -514019

       659       123
  Directly:              81057
  DVEC_MUL               81057

      -169      -868
  Directly:             146692
  DVEC_MUL              146692

      -485      -780
  Directly:             378300
  DVEC_MUL              378300

      -913       268
  Directly:            -244684
  DVEC_MUL             -244684

      -877      -101
  Directly:              88577
  DVEC_MUL               88577

      -197       510
  Directly:            -100470
  DVEC_MUL             -100470

       595      -997
  Directly:            -593215
  DVEC_MUL             -593215

       795      -299
  Directly:            -237705
  DVEC_MUL             -237705

      -811      -973
  Directly:             789103
  DVEC_MUL              789103

  NOW REPEAT THE TEST...

  but use too few digits to represent big products.
  This corresponds to an "overflow".
  The result here should get the final decimal
  digits correctly, though.

        I        J        K = I * J


       719       682
  Directly:             490358
  DVEC_MUL               90358

      -754      -985
  Directly:             742690
  DVEC_MUL               42690

      -480       825
  Directly:            -396000
  DVEC_MUL              -96000

      -773      -297
  Directly:             229581
  DVEC_MUL               29581

       646      -466
  Directly:            -301036
  DVEC_MUL               -1036

       384       123
  Directly:              47232
  DVEC_MUL               47232

       723       -92
  Directly:             -66516
  DVEC_MUL              -66516

       824       196
  Directly:             161504
  DVEC_MUL               61504

      -622       523
  Directly:            -325306
  DVEC_MUL              -25306

      -206      -630
  Directly:             129780
  DVEC_MUL               29780

DVEC_PRINT_TEST
  DVEC_PRINT prints a (signed) decimal vector;

  The DVEC:

  -0055771439876543210

DVEC_SUB_TEST
  DVEC_SUB subtracts decimal vectors representing integers;

        I        J        L = I - J


       -57        92
  Directly:               -149
            DVEC_SUB      -149

        66        12
  Directly:                 54
            DVEC_SUB        54

       -17       -87
  Directly:                 70
            DVEC_SUB        70

       -49       -78
  Directly:                 29
            DVEC_SUB        29

       -92        27
  Directly:               -119
            DVEC_SUB      -119

       -88       -10
  Directly:                -78
            DVEC_SUB       -78

       -20        51
  Directly:                -71
            DVEC_SUB       -71

        60      -100
  Directly:                160
            DVEC_SUB       160

        80       -30
  Directly:                110
            DVEC_SUB       110

       -81       -98
  Directly:                 17
            DVEC_SUB        17

DVEC_TO_I4_TEST
  DVEC_TO_I4 converts a DVEC to an I4

        I4 => DVEC => I4

   -5632   9 9 4 3 6 8   -5632

EQUIV_NEXT_TEST
  EQUIV_NEXT generates all partitions of a set.

  Rank/element:   1   2   3   4

     1   1   1   1   1
     2   1   1   1   2
     3   1   1   2   1
     4   1   1   2   2
     5   1   1   2   3
     6   1   2   1   1
     7   1   2   1   2
     8   1   2   1   3
     9   1   2   2   1
    10   1   2   2   2
    11   1   2   2   3
    12   1   2   3   1
    13   1   2   3   2
    14   1   2   3   3
    15   1   2   3   4

EQUIV_NEXT2_TEST
  EQUIV_NEXT2 generates all partitions of a set.
  Here, N =        4

  Rank/element:   1   2   3   4

     1             1   1   1   1
     2             1   1   1   2
     3             1   1   2   1
     4             1   1   2   2
     5             1   1   2   3
     6             1   2   1   1
     7             1   2   1   2
     8             1   2   1   3
     9             1   2   2   1
    10             1   2   2   2
    11             1   2   2   3
    12             1   2   3   1
    13             1   2   3   2
    14             1   2   3   3
    15             1   2   3   4

EQUIV_PRINT_TEST
  EQUIV_PRINT prints a set partition.

  The set partition:

   Set  Size
       1       1 ::    1
       2       3 ::    2   3   4

  The set partition:

   Set  Size
       1       1 ::    4
       2       1 ::    1
       3       1 ::    2
       4       1 ::    3

  The set partition:

   Set  Size
       1       2 ::    1   4
       2       2 ::    2   3

  The set partition:

   Set  Size
       1       2 ::    1   3
       2       1 ::    4
       3       1 ::    2

  The set partition:

   Set  Size
       1       1 ::    3
       2       1 ::    2
       3       2 ::    1   4

EQUIV_PRINT2_TEST
  EQUIV_PRINT2 prints a set partition.

  The set partition:

( 1)( 2, 3, 4)

  The set partition:

( 4)( 1)( 2)( 3)

  The set partition:

( 1, 4)( 2, 3)

  The set partition:

( 1, 3)( 4)( 2)

  The set partition:

( 3)( 2)( 1, 4)

EQUIV_RANDOM_TEST
  EQUIV_RANDOM selects a random set partition.

  The set partition:

( 1)( 2, 3, 4)

  The set partition:

( 4)( 1)( 2)( 3)

  The set partition:

( 1, 4)( 2, 3)

  The set partition:

( 1, 3)( 4)( 2)

  The set partition:

( 3)( 2)( 1, 4)

EULER_ROW_TEST
  EULER_ROW gets rows of Euler's triangle.

        1
        1      0
        1      1      0
        1      4      1      0
        1     11     11      1      0
        1     26     66     26      1      0
        1     57    302    302     57      1      0
        1    120   1191   2416   1191    120      1      0
        1    247   4293  15619  15619   4293    247      1      0
        1    502  14608  88234 156190  88234  14608    502      1      0

FROBENIUS_NUMBER_ORDER2_TEST
  FROBENIUS_NUMBER_ORDER2 computes Frobenius numbers of order 2.

        C1        C1   exact F  comput F

         2         5         3         3
         3        17        31        31
         4        19        23        53
         5        13        47        47
        12        11       109       109
        99       100      9701      9701

GRAY_NEXT_TEST
  GRAY_NEXT returns the index of the single item
  to be changed in order to get the next Gray code.

   K  Change  Gray Code

   1         0  0000
   2         1  1000
   3         2  1100
   4        -1  0100
   5         3  0110
   6         1  1110
   7        -2  1010
   8        -1  0010
   9         4  0011
  10         1  1011
  11         2  1111
  12        -1  0111
  13        -3  0101
  14         1  1101
  15        -2  1001
  16        -1  0001

GRAY_RANK1_TEST
  GRAY_RANK1 ranks a Gray code;

    R  =                         RANK
    G  =            GRAY_UNRANK1(RANK)
    R2 = GRAY_RANK1(GRAY_UNRANK1(RANK))

         R         G         R2

         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24

GRAY_RANK2_TEST
  GRAY_RANK2 ranks a Gray code;

    R  =                         RANK
    G  =            GRAY_UNRANK2(RANK)
    R2 = GRAY_RANK2(GRAY_UNRANK2(RANK))

         R         G         R2

         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24

GRAY_UNRANK1_TEST
  GRAY_UNRANK1 unranks a Gray code.

    R  =                         RANK
    G  =            GRAY_UNRANK1(RANK)
    R2 = GRAY_RANK1(GRAY_UNRANK1(RANK))

         R         G         R2

         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24

GRAY_UNRANK2_TEST
  GRAY_UNRANK2 unranks a Gray code.

    R  =                         RANK
    G  =            GRAY_UNRANK2(RANK)
    R2 = GRAY_RANK2(GRAY_UNRANK2(RANK))

         R         G         R2

         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24
 
I4_BCLR_TEST
  I4_BCLR sets a given bit to 0.
 
  Working on I4 =      101
 
       Pos     I4_BCLR(I4,POS)
 
         0           100
         1           101
         2            97
         3           101
         4           101
         5            69
         6            37
         7           101
         8           101
         9           101
        10           101
        11           101
        12           101
        13           101
        14           101
        15           101
        16           101
        17           101
        18           101
        19           101
        20           101
        21           101
        22           101
        23           101
        24           101
        25           101
        26           101
        27           101
        28           101
        29           101
        30           101
        31           101
 
  Working on I4 =      -31
 
       Pos     I4_BCLR(I4,POS)
 
         0           -32
         1           -31
         2           -31
         3           -31
         4           -31
         5           -63
         6           -95
         7          -159
         8          -287
         9          -543
        10         -1055
        11         -2079
        12         -4127
        13         -8223
        14        -16415
        15        -32799
        16        -65567
        17       -131103
        18       -262175
        19       -524319
        20      -1048607
        21      -2097183
        22      -4194335
        23      -8388639
        24     -16777247
        25     -33554463
        26     -67108895
        27    -134217759
        28    -268435487
        29    -536870943
        30   -1073741855
        31    2147483617
 
I4_BSET_TEST
  I4_BSET sets a given bit to 1.
 
  Working on I4 =      101
 
       Pos     I4_BSET(I4,POS)
 
         0           101
         1           103
         2           101
         3           109
         4           117
         5           101
         6           101
         7           229
         8           357
         9           613
        10          1125
        11          2149
        12          4197
        13          8293
        14         16485
        15         32869
        16         65637
        17        131173
        18        262245
        19        524389
        20       1048677
        21       2097253
        22       4194405
        23       8388709
        24      16777317
        25      33554533
        26      67108965
        27     134217829
        28     268435557
        29     536871013
        30    1073741925
        31   -2147483547
 
  Working on I4 =      -31
 
       Pos     I4_BSET(I4,POS)
 
         0           -31
         1           -29
         2           -27
         3           -23
         4           -15
         5           -31
         6           -31
         7           -31
         8           -31
         9           -31
        10           -31
        11           -31
        12           -31
        13           -31
        14           -31
        15           -31
        16           -31
        17           -31
        18           -31
        19           -31
        20           -31
        21           -31
        22           -31
        23           -31
        24           -31
        25           -31
        26           -31
        27           -31
        28           -31
        29           -31
        30           -31
        31           -31
 
I4_BTEST_TEST
  I4_BTEST reports whether a given bit is 0 or 1.
 
  Analyze the integer I4 =      101
 
       Pos     I4_BTEST(I4,POS)
 
         0             T
         1             F
         2             T
         3             F
         4             F
         5             T
         6             T
         7             F
         8             F
         9             F
        10             F
        11             F
        12             F
        13             F
        14             F
        15             F
        16             F
        17             F
        18             F
        19             F
        20             F
        21             F
        22             F
        23             F
        24             F
        25             F
        26             F
        27             F
        28             F
        29             F
        30             F
        31             F
 
  Analyze the integer I4 =      -31
 
       Pos     I4_BTEST(I4,POS)
 
         0             T
         1             F
         2             F
         3             F
         4             F
         5             T
         6             T
         7             T
         8             T
         9             T
        10             T
        11             T
        12             T
        13             T
        14             T
        15             T
        16             T
        17             T
        18             T
        19             T
        20             T
        21             T
        22             T
        23             T
        24             T
        25             T
        26             T
        27             T
        28             T
        29             T
        30             T
        31             T

I4_CHOOSE_TEST
  I4_CHOOSE evaluates C(N,K).

         N         K       CNK

         0         0         1

         1         0         1
         1         1         1

         2         0         1
         2         1         2
         2         2         1

         3         0         1
         3         1         3
         3         2         3
         3         3         1

         4         0         1
         4         1         4
         4         2         6
         4         3         4
         4         4         1

I4_FACTOR_TEST
  I4_FACTOR factors an integer,

  The integer is     2516

  Prime representation:

         I  FACTOR(I)  POWER(I)

         1       2       2
         2      17       1
         3      37       1

I4_FALL_TEST:
  I4_FALL evaluates the falling factorial function:

         M         N      Exact         I4_FALL(M,N)

         5         0             1             1
         5         1             5             5
         5         2            20            20
         5         3            60            60
         5         4           120           120
         5         5           120           120
         5         6             0             0
        50         0             1             1
        10         1            10            10
      4000         1          4000          4000
        10         2            90            90
        18         3          4896          4896
         4         4            24            24
        98         3        912576        912576
         1         7             0             0

I4_GCD_TEST
  I4_GCD computes the greatest common divisor
  of two integers.

         I       J    I4_GCD(I,J)

        -1      15       1
        12       9       3
         3       1       1
         0       2       2
        -5      10       5
        -4       7       1
         3      12       3
        11       1       1
        13       6       1
        -4       1       1
        13      13      13
        -3       1       1
         0      14      14
        -3       6       3
        12       5       1
 
I4_HUGE_TEST
  I4_HUGE returns a huge integer.
 
  I4_HUGE() =   2147483647
  HUGE(1) =     2147483647

I4_LOG_10_TEST
  I4_LOG_10: whole part of log base 10,

         X        I4_LOG_10

         0           0
         1           0
         2           0
         3           0
         9           0
        10           1
        11           1
        99           1
       100           2
       101           2
       999           2
      1000           3
      1001           3
        -1           0
        -2           0
        -3           0
        -9           0
       -10           1
       -11           1
       -99           1
      -101           2
 
I4_MODP_TEST
  I4_MODP factors a number
  into a multiple and a positive remainder.
 
    Number   Divisor  Multiple Remainder
 
         107        50         2         7
         107       -50        -2         7
        -107        50        -3        43
        -107       -50         3        43
 
  Repeat using FORTRAN MOD:
 
         107        50         2         7
         107       -50        -2         7
        -107        50        -2        -7
        -107       -50         2        -7

I4_MOEBIUS_TEST:
  I4_MOEBIUS evaluates the Moebius function:

         N      Exact         I4_MOEBIUS(N)

         1             1             1
         2            -1            -1
         3            -1            -1
         4             0             0
         5            -1            -1
         6             1             1
         7            -1            -1
         8             0             0
         9             0             0
        10             1             1
        11            -1            -1
        12             0             0
        13            -1            -1
        14             1             1
        15             1             1
        16             0             0
        17            -1            -1
        18             0             0
        19            -1            -1
        20             0             0

I4_PARTITION_CONJ_TEST
  I4_PARTITION_CONJ conjugates an integer partition.

  Original partition:

  14 = 1 * 2 + 1 * 5 + 3 * 1 + 1 * 4

  Conjugate partition:

  14 = 1 * 6 + 1 * 3 + 2 * 2 + 1 * 1

I4_PARTITION_COUNT_TEST
  I4_PARTITION_COUNT counts partitions of an integer.

   N     Exact     Count

     0         1         1
     1         1         1
     2         2         2
     3         3         3
     4         5         5
     5         7         7
     6        11        11
     7        15        15
     8        22        22
     9        30        30
    10        42        42
    11        56        56
    12        77        77
    13       101       101
    14       135       135
    15       176       176
    16       231       231
    17       297       297
    18       385       385
    19       490       490
    20       627       627

I4_PARTITION_COUNT2_TEST
  I4_PARTITION_COUNT2 counts partitions of an integer.

   N     Exact     Count

     0         1         1
     1         1         1
     2         2         2
     3         3         3
     4         5         5
     5         7         7
     6        11        11
     7        15        15
     8        22        22
     9        30        30
    10        42        42
    11        56        56
    12        77        77
    13       101       101
    14       135       135
    15       176       176
    16       231       231
    17       297       297
    18       385       385
    19       490       490
    20       627       627

I4_PARTITION_NEXT_TEST
  I4_PARTITION_NEXT generates partitions of an integer.
  Here N =        7

  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1

I4_PARTITION_NEXT2_TEST
  I4_PARTITION_NEXT2 produces partitions of an integer.

  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1

I4_PARTITION_PRINT_TEST
  I4_PARTITION_PRINT prints an integer partition.

  14 = 1 * 2 + 1 * 5 + 3 * 1 + 1 * 4

I4_PARTITION_RANDOM_TEST
  I4_PARTITION_RANDOM generates a random partition.


  The number of partitions of N

       N    Number of partitions

         0           1
         1           1
         2           2
         3           3
         4           5
         5           7
         6          11
         7          15
         8          22

  8 = 5 * 1 + 1 * 3
  8 = 2 * 1 + 1 * 6
  8 = 4 * 1 + 2 * 2
  8 = 4 * 1 + 1 * 4
  8 = 1 * 1 + 1 * 2 + 1 * 5

I4_PARTITIONS_NEXT_TEST
  I4_PARTITIONS_NEXT produces the next
  nondecreasing partitions of an integer, and
  if necessary, increments the integer to keep on going.

   I Sum    Partition

   0   0     0 0 0
   1   1     1 0 0
   2   2     2 0 0
   3   2     1 1 0
   4   3     3 0 0
   5   3     2 1 0
   6   3     1 1 1
   7   4     4 0 0
   8   4     3 1 0
   9   4     2 2 0
  10   4     2 1 1
  11   5     5 0 0
  12   5     4 1 0
  13   5     3 2 0
  14   5     3 1 1
  15   5     2 2 1

  You can start from any legal partition.
  Here, we restart at ( 2, 1, 0 ).

   I Sum    Partition

   0   3     2 1 0
   1   3     1 1 1
   2   4     4 0 0
   3   4     3 1 0
   4   4     2 2 0
   5   4     2 1 1
   6   5     5 0 0
   7   5     4 1 0
   8   5     3 2 0
   9   5     3 1 1
  10   5     2 2 1
  11   6     6 0 0
  12   6     5 1 0
  13   6     4 2 0
  14   6     3 3 0
  15   6     4 1 1

I4_RISE_TEST:
  I4_RISE evaluates the rising factorial function:

         M         N      Exact         I4_RISE(M,N)

         5         0             1             1
         5         1             5             5
         5         2            30            30
         5         3           210           210
         5         4          1680          1680
         5         5         15120         15120
         5         6        151200        151200
        50         0             1             1
        10         1            10            10
      4000         1          4000          4000
        10         2           110           110
        18         3          6840          6840
         4         4           840           840
        98         3        970200        970200
         1         7          5040          5040

I4_SQRT_TEST
  I4_SQRT computes the square root of an integer.

       N  Sqrt(N) Remainder

         -5        2        1
         -4        2        0
         -3        1        2
         -2        1        1
         -1        1        0
          0        0        0
          1        1        0
          2        1        1
          3        1        2
          4        2        0
          5        2        1
          6        2        2
          7        2        3
          8        2        4
          9        3        0
         10        3        1
         11        3        2
         12        3        3
         13        3        4
         14        3        5
         15        3        6
         16        4        0
         17        4        1
         18        4        2
         19        4        3
         20        4        4

I4_SQRT_CF_TEST
  I4_SQRT_CF computes the continued fraction form
  of the square root of an integer.

   N  Period  Whole  Repeating Part

      1       0      1
      2       1      1    2
      3       2      1    1    2
      4       0      2
      5       1      2    4
      6       2      2    2    4
      7       4      2    1    1    1    4
      8       2      2    1    4
      9       0      3
     10       1      3    6
     11       2      3    3    6
     12       2      3    2    6
     13       5      3    1    1    1    1    6
     14       4      3    1    2    1    6
     15       2      3    1    6
     16       0      4
     17       1      4    8
     18       2      4    4    8
     19       6      4    2    1    3    1    2    8
     20       2      4    2    8

I4_TO_CHINESE_TEST
  I4_TO_CHINESE computes the Chinese Remainder
  representation of an integer.

  The moduli:

       1         3
       2         4
       3         5
       4         7

  The number being analyzed is       37

  The remainders:

       1         1
       2         1
       3         2
       4         2

  The reconstructed number is       37

  The remainders of the reconstructed number are:

       1         1
       2         1
       3         2
       4         2

I4_TO_DVEC_TEST
  I4_TO_DVEC converts a DVEC to an I4

        I4 => DVEC => I4

   -5632   9 9 4 3 6 8   -5632

I4_TO_I4POLY_TEST
  I4_TO_I4POLY converts an integer to a polynomial
  in a given base;

       I    BASE  DEGREE  Coefficients

     1     2     0             1
     6     2     2             1       1       0
    23     2     4             1       0       1       1       1
    23     3     2             2       1       2
    23     4     2             1       1       3
    23     5     1             4       3
    23     6     1             3       5
    23    23     1             1       0
    23    24     0            23

  Now let I4_TO_I4POLY convert I to a polynomial,
  use I4POLY_TO_I4 to evaluate it, and compare.

       I    I2

         1         1
         6         6
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23

I4_TO_VAN_DER_CORPUT_TEST
  I4_TO_VAN_DER_CORPUT computes the elements 
  of a van der Corput sequence.
  The sequence depends on the prime numbers used 
  as a base.

  Bases:

                 2               3               5               7              11

    1  0.500000      0.333333      0.200000      0.142857      0.909091E-01
    2  0.250000      0.666667      0.400000      0.285714      0.181818    
    3  0.750000      0.111111      0.600000      0.428571      0.272727    
    4  0.125000      0.444444      0.800000      0.571429      0.363636    
    5  0.625000      0.777778      0.400000E-01  0.714286      0.454545    
    6  0.375000      0.222222      0.240000      0.857143      0.545455    
    7  0.875000      0.555556      0.440000      0.204082E-01  0.636364    
    8  0.625000E-01  0.888889      0.640000      0.163265      0.727273    
    9  0.562500      0.370370E-01  0.840000      0.306122      0.818182    
   10  0.312500      0.370370      0.800000E-01  0.448980      0.909091    

I4MAT_01_ROWCOLSUM_TEST
  I4MAT_01_ROWCOLSUM constructs a 01 matrix with
  given row and column sums.

  The rowsum vector R:

       1        14
       2        13
       3        14
       4        10
       5        12
       6         2
       7        10
       8         1
       9        10
      10        11
      11         6
      12         2
      13        17

  The columnsum vector C:

       1         4
       2         4
       3        11
       4        10
       5        10
       6         8
       7         9
       8        10
       9         8
      10         9
      11         3
      12        10
      13         4
      14         7
      15         9
      16         3
      17         3

  The rowcolsum matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        0      1      1      1      1      1      1      1      1      1
       2        1      0      1      1      1      0      1      1      1      1
       3        1      0      1      1      1      1      1      1      0      1
       4        0      0      1      0      1      1      1      1      1      1
       5        1      1      1      1      1      1      1      1      1      1
       6        0      0      0      1      1      0      0      0      0      0
       7        0      0      1      1      0      1      1      1      1      1
       8        0      0      0      1      0      0      0      0      0      0
       9        0      0      1      1      0      1      1      1      1      1
      10        0      1      1      1      1      1      1      1      1      0
      11        0      0      1      0      1      0      0      1      0      1
      12        0      0      1      0      1      0      0      0      0      0
      13        1      1      1      1      1      1      1      1      1      1

  Col        11     12     13     14     15     16     17
  Row

       1        1      1      1      0      1      1      0
       2        0      1      1      1      1      0      1
       3        0      1      1      1      1      1      1
       4        0      1      0      1      1      0      0
       5        0      1      0      1      0      0      0
       6        0      0      0      0      0      0      0
       7        0      1      0      1      1      0      0
       8        0      0      0      0      0      0      0
       9        0      1      0      1      1      0      0
      10        0      1      0      1      1      0      0
      11        0      1      0      0      1      0      0
      12        0      0      0      0      0      0      0
      13        2      1      1      0      1      1      1

  Computed row sums

       1        14
       2        13
       3        14
       4        10
       5        12
       6         2
       7        10
       8         1
       9        10
      10        11
      11         6
      12         2
      13        17

  Computed column sums:

       1         4
       2         4
       3        11
       4        10
       5        10
       6         8
       7         9
       8        10
       9         8
      10         9
      11         3
      12        10
      13         4
      14         7
      15         9
      16         3
      17         3

I4MAT_01_ROWCOLSUM2_TEST
  I4MAT_01_ROWCOLSUM2 constructs a 01 matrix with
  given row and column sums.

  The rowsum vector:

       1         2
       2         1
       3         3
       4         1
       5         2

  The columnsum vector:

       1         2
       2         1
       3         2
       4         2
       5         2

  The rowcolsum matrix:

  Col         1      2      3      4      5
  Row

       1        0      0      1      1      0
       2        0      0      0      1      0
       3        0      1      1      0      1
       4        1      0      0      0      0
       5        1      0      0      0      1

  Now repeat, with data for which there is not
  a solution.  The program will try its best anyway.

  The rowsum vector:

       1         1
       2         3
       3         4
       4         1
       5         3

  The columnsum vector:

       1         1
       2         4
       3         1
       4         5
       5         1

  I4MAT_01_ROWCOLSUM2 returned error flag IERROR =        1
  The matrix returned is not an exact solution.

  The rowcolsum matrix:

  Col         1      2      3      4      5
  Row

       1        0      0      0      1      0
       2        0      1      1      1      0
       3        1      1      0      1      1
       4        0      1      0      1     -1
       5        0      1      0      1      1

I4MAT_U1_INVERSE_TEST
  I4MAT_U1_INVERSE inverts a unit upper triangular matrix.

  The input matrix:

  Col         1      2      3      4      5      6
  Row

       1        1      1      0      0      0     75
       2        0      1      0      0      0      0
       3        0      0      1      1      0      0
       4        0      0      0      1      0      0
       5        0      0      0      0      1      1
       6        0      0      0      0      0      1

  The inverse:

  Col         1      2      3      4      5      6
  Row

       1        1     -1      0      0      0    -75
       2        0      1      0      0      0      0
       3        0      0      1     -1      0      0
       4        0      0      0      1      0      0
       5        0      0      0      0      1     -1
       6        0      0      0      0      0      1

I4MAT_PERM1_TEST
  I4MAT_PERM1 reorders an integer matrix in place.
  The rows and columns use the same permutation.

  The input matrix:

  Col         1      2      3      4      5      6      7      8      9
  Row

       1       11     12     13     14     15     16     17     18     19
       2       21     22     23     24     25     26     27     28     29
       3       31     32     33     34     35     36     37     38     39
       4       41     42     43     44     45     46     47     48     49
       5       51     52     53     54     55     56     57     58     59
       6       61     62     63     64     65     66     67     68     69
       7       71     72     73     74     75     76     77     78     79
       8       81     82     83     84     85     86     87     88     89
       9       91     92     93     94     95     96     97     98     99

  The row and column permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permuted matrix:

  Col         1      2      3      4      5      6      7      8      9
  Row

       1       99     91     92     98     97     94     95     96     93
       2       19     11     12     18     17     14     15     16     13
       3       29     21     22     28     27     24     25     26     23
       4       89     81     82     88     87     84     85     86     83
       5       79     71     72     78     77     74     75     76     73
       6       49     41     42     48     47     44     45     46     43
       7       59     51     52     58     57     54     55     56     53
       8       69     61     62     68     67     64     65     66     63
       9       39     31     32     38     37     34     35     36     33

I4MAT_2PERM1_TEST
  I4MAT_2PERM1 reorders an integer matrix in place.
  Rows and columns use different permutations.

  The input matrix:

  Col         1      2      3      4      5      6      7
  Row

       1       11     12     13     14     15     16     17
       2       21     22     23     24     25     26     27
       3       31     32     33     34     35     36     37
       4       41     42     43     44     45     46     47
       5       51     52     53     54     55     56     57
       6       61     62     63     64     65     66     67
       7       71     72     73     74     75     76     77
       8       81     82     83     84     85     86     87
       9       91     92     93     94     95     96     97

  The row permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The column permutation:

     1   2   3   4   5   6   7
     3   4   5   6   7   1   2

  The permuted matrix:

  Col         1      2      3      4      5      6      7
  Row

       1       96     97     91     92     93     94     95
       2       16     17     11     12     13     14     15
       3       26     27     21     22     23     24     25
       4       86     87     81     82     83     84     85
       5       76     77     71     72     73     74     75
       6       46     47     41     42     43     44     45
       7       56     57     51     52     53     54     55
       8       66     67     61     62     63     64     65
       9       36     37     31     32     33     34     35

I4POLY_TEST
  I4POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial

  All calls have input A as follows
   0   0   0   0   0   1

  Option IOPT =       -3
  Output array = 
     0  24 -50  35 -10   1

  Option IOPT =       -2
  Output array = 
     0   1  15  25  10   1

  Option IOPT =       -1
  X0 =        2
  Value =        0

  Option IOPT =        0
  X0 =        2
  Value =       32

  Option IOPT =        6
  X0 =        2
  Output array = 
    32  80  80  40  10   1

  Option IOPT =        6
  X0 =       -2
  Output array = 
   -32  80 -80  40 -10   1

I4POLY_ADD_TEST
  I4POLY_ADD adds two I4POLY's.

  Polynomial A:

  p(x) =         5 * x ^   5
         +       4 * x ^   4
         +       3 * x ^   3
         +       2 * x ^   2
         +       1 * x

  Polynomial B:

  p(x) = -       5 * x ^   5
         +       8 * x ^   3
         +       7 * x ^   2
         -       2 * x
         +       1

  Polynomial C = A+B:

  p(x) =         4 * x ^   4
         +      11 * x ^   3
         +       9 * x ^   2
         -       1 * x
         +       1

I4POLY_CYCLO_TEST
  I4POLY_CYCLO computes cyclotomic polynomials.

  N =        0


  The cyclotomic polynomial:

  p(x) =         1

  N =        1


  The cyclotomic polynomial:

  p(x) =         1 * x
         -       1

  N =        2


  The cyclotomic polynomial:

  p(x) =         1 * x
         +       1

  N =        3


  The cyclotomic polynomial:

  p(x) =         1 * x ^   2
         +       1 * x
         +       1

  N =        4


  The cyclotomic polynomial:

  p(x) =         1 * x ^   2
         +       1

  N =        5


  The cyclotomic polynomial:

  p(x) =         1 * x ^   4
         +       1 * x ^   3
         +       1 * x ^   2
         +       1 * x
         +       1

  N =        6


  The cyclotomic polynomial:

  p(x) =         1 * x ^   2
         -       1 * x
         +       1

  N =        7


  The cyclotomic polynomial:

  p(x) =         1 * x ^   6
         +       1 * x ^   5
         +       1 * x ^   4
         +       1 * x ^   3
         +       1 * x ^   2
         +       1 * x
         +       1

  N =        8


  The cyclotomic polynomial:

  p(x) =         1 * x ^   4
         +       1

  N =        9


  The cyclotomic polynomial:

  p(x) =         1 * x ^   6
         +       1 * x ^   3
         +       1

  N =       10


  The cyclotomic polynomial:

  p(x) =         1 * x ^   4
         -       1 * x ^   3
         +       1 * x ^   2
         -       1 * x
         +       1

I4POLY_DEGREE_TEST
  I4POLY_DEGREE returns the degree of an I4POLY.

  The polynomial:

  p(x) =         7 * x ^   7
         +       6 * x ^   6
         +       4 * x ^   4
         +       2 * x ^   2
         +       1 * x

  The polynomial degree is    7

I4POLY_DIF_TEST
  I4POLY_DIF computes derivatives of an I4POLY.


  The polynomial A:

  p(x) =         1 * x ^   3
         +       2 * x ^   2
         -       5 * x
         -       6

  Differentiate A  1 times.

  The derivative, B:

  p(x) =         3 * x ^   2
         +       4 * x
         -       5

  The polynomial A:

  p(x) =         1 * x ^   4
         +       3 * x ^   3
         +       2 * x ^   2
         +       5 * x
         -       2

  Differentiate A  3 times.

  The derivative, B:

  p(x) =        24 * x
         +      18

I4POLY_DIV_TEST
  I4POLY_DIV computes the quotient and
  remainder for polynomial division.


  The polynomial to be divided, A:

  p(x) =         1 * x ^   3
         +       2 * x ^   2
         -       5 * x
         -       6

  The divisor polynomial, B:

  p(x) =         1 * x
         -       2

  The quotient polynomial, Q:

  p(x) =         1 * x ^   2
         +       4 * x
         +       3

  The remainder polynomial, R:

  p(x) =         0

  The polynomial to be divided, A:

  p(x) =         1 * x ^   4
         +       3 * x ^   3
         +       2 * x ^   2
         +       5 * x
         -       2

  The divisor polynomial, B:

  p(x) =         1 * x ^   2
         +       1 * x
         -       3

  The quotient polynomial, Q:

  p(x) =         1 * x ^   2
         +       2 * x
         +       3

  The remainder polynomial, R:

  p(x) =         8 * x
         +       7

I4POLY_MUL_TEST
  I4POLY_MUL multiplies two polynomials.


  The factor A:

  p(x) =         1 * x
         +       1

  The factor B:

  p(x) = -       1 * x
         +       1

  The product C = A*B:

  p(x) = -       1 * x ^   2
         +       1

  The factor A:

  p(x) =         3 * x ^   2
         +       2 * x
         +       1

  The factor B:

  p(x) = -       2 * x
         +       1

  The product C = A*B:

  p(x) = -       6 * x ^   3
         -       1 * x ^   2
         +       1

I4POLY_PRINT_TEST
  I4POLY_PRINT prints an I4POLY.

  The polynomial:

  p(x) =         1 * x ^   4
         +       3 * x ^   3
         +       2 * x ^   2
         +       5 * x
         -       2

I4POLY_TO_I4_TEST
  I4POLY_TO_I4 evaluates an integer polynomial.

       I    BASE  DEGREE  Coefficients

     1     2     0             1
     6     2     2             1       1       0
    23     2     4             1       0       1       1       1
    23     3     2             2       1       2
    23     4     2             1       1       3
    23     5     1             4       3
    23     6     1             3       5
    23    23     1             1       0
    23    24     0            23

  Now let I4_TO_I4POLY convert I to a polynomial,
  use I4POLY_TO_I4 to evaluate it, and compare.

       I    I2

         1         1
         6         6
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23

I4VEC_BACKTRACK_TEST
  I4VEC_BACKTRACK uses backtracking, seeking a vector X
  of N values which satisfies some condition.

  In this demonstration, we have 8 integers W(I).
  We seek all subsets that sum to 53.
  X(I) is 0 or 1 if the entry is skipped or used.

   1      53:    15  22  16
   2      53:    15  14  16   8
   3      53:    22  14   9   8

  Done!

I4VEC_DESCENDS_TEST
  I4VEC_DESCENDS is true if an integer vector decreases.


  The integer array to search:

       1         1
       2         4
       3         4
       4         3
  The preceding vector is not descending.

  The integer array to search:

       1         2
       2         1
       3         2
       4         1
  The preceding vector is not descending.

  The integer array to search:

       1         1
       2         3
       3         1
       4         2
  The preceding vector is not descending.

  The integer array to search:

       1         2
       2         4
       3         4
       4         1
  The preceding vector is not descending.

  The integer array to search:

       1         4
       2         2
       3         1
       4         1
  The preceding vector is descending.

I4VEC_FRAC_TEST
  I4VEC_FRAC: K-th smallest integer vector entry.


  The integer array to search:

       1         5
       2        20
       3        17
       4        12
       5         9
       6         2
       7         6
       8         3
       9         1
      10        13

       K       K-th smallest

         1         1
         2         2
         3         3
         4         5
         5         6
         6         9
         7        12
         8        13
         9        17
        10        20

I4VEC_INDEX_TEST
  I4VEC_INDEX returns the index of the first occurrence
  of a given value in an integer vector.


  The integer array to search:

       1         3
       2        10
       3         9
       4         6
       5         5
       6         1
       7         3
       8         2
       9         1
      10         7
      11         1
      12         5
      13         5
      14         8
      15         8
      16         1
      17         9
      18         4
      19         1
      20         1

  The value searched for is        7
  The index of first occurrence is       10

I4VEC_MAXLOC_LAST_TEST
  I4VEC_MAXLOC_LAST: index of the last maximal
  entry in an integer vector.


  The integer array to search:

       1         2
       2         5
       3         5
       4         3
       5         3
       6         1
       7         2
       8         1
       9         1
      10         4
      11         1
      12         3
      13         3
      14         4
      15         4
      16         1
      17         5
      18         2
      19         1
      20         1

  Index of last maximal entry is       17

I4VEC_PAIRWISE_PRIME_TEST
  I4VEC_PAIRWISE_PRIME is true if an integer vector
  is pairwise prime.


  The integer array to check:

       1         1
       2         4
       3         4
       4         3
  The preceding vector is not pairwise prime.

  The integer array to check:

       1         2
       2         1
       3         2
       4         1
  The preceding vector is not pairwise prime.

  The integer array to check:

       1         1
       2         3
       3         1
       4         2
  The preceding vector is pairwise prime.

  The integer array to check:

       1         2
       2         4
       3         4
       4         1
  The preceding vector is not pairwise prime.

  The integer array to check:

       1         4
       2         2
       3         1
       4         1
  The preceding vector is not pairwise prime.

i4VEC_REVERSE_TEST
  I4VEC_REVERSE reverses an integer vector.


  The integer array:

       1         2
       2         5
       3         5
       4         3
       5         3

  The reversed integer array:

       1         3
       2         3
       3         5
       4         5
       5         2

I4VEC_SORT_BUBBLE_A_TEST
  I4VEC_SORT_BUBBLE_A ascending sorts an integer vector
  using bubble sort.


  Unsorted array:

       1        13
       2        58
       3        50
       4        34
       5        25
       6         4
       7        15
       8         6
       9         2
      10        38
      11         3
      12        27
      13        24
      14        46
      15        48
      16         0
      17        54
      18        21
      19         5
      20         0

  Sorted array:

       1         0
       2         0
       3         2
       4         3
       5         4
       6         5
       7         6
       8        13
       9        15
      10        21
      11        24
      12        25
      13        27
      14        34
      15        38
      16        46
      17        48
      18        50
      19        54
      20        58

I4VEC_SORT_HEAP_INDEX_D_TEST
  I4VEC_SORT_HEAP_INDEX_D descending index-sorts
  an integer vector using heap sort.


  Unsorted array:

       1        13
       2        58
       3        50
       4        34
       5        25
       6         4
       7        15
       8         6
       9         2
      10        38
      11         3
      12        27
      13        24
      14        46
      15        48
      16         0
      17        54
      18        21
      19         5
      20         0

       I    INDX    A(INDX)

         1       2      58
         2      17      54
         3       3      50
         4      15      48
         5      14      46
         6      10      38
         7       4      34
         8      12      27
         9       5      25
        10      13      24
        11      18      21
        12       7      15
        13       1      13
        14       8       6
        15      19       5
        16       6       4
        17      11       3
        18       9       2
        19      20       0
        20      16       0
 
I4VEC_TRANSPOSE_PRINT_TEST
  I4VEC_TRANSPOSE_PRINT prints an I4VEC
  with 5 entries to a row, and an optional title.
 
  Array printed by I4VEC_TRANSPOSE_PRINT:
           1           2           3           4           5
           6           7           8           9          10
          11          12
 
I4VEC_UNIFORM_AB_TEST
  I4VEC_UNIFORM_AB computes pseudorandom values 
  in an interval [A,B].
 
  The lower endpoint A =         -100
  The upper endpoint B =          200
  The initial seed is    123456789

  The random vector:

       1       -35
       2       187
       3       149
       4        69
       5        25
       6       -81
       7       -23
       8       -67
       9       -87
      10        90
      11       -82
      12        35
      13        20
      14       127
      15       139
      16      -100
      17       170
      18         5
      19       -72
      20       -96

INDEX_BOX_NEXT_2D_TEST
  INDEX_BOX_NEXT_2D produces IJ indices that
  lie on the surface of a box in 2D.

  The box has logical dimensions:
     5  3

   #    I   J

    1  1  1
    2  1  2
    3  1  3
    4  2  1
    5  2  3
    6  3  1
    7  3  3
    8  4  1
    9  4  3
   10  5  1
   11  5  2
   12  5  3

INDEX_BOX_NEXT_3D_TEST
  INDEX_BOX_NEXT_3D produces IJK indices that
  lie on the surface of a box.

  The box has logical dimensions:
     5  3  4

     #    I   J   K

    1  1  1  1
    2  1  1  2
    3  1  1  3
    4  1  1  4
    5  1  2  1
    6  1  2  2
    7  1  2  3
    8  1  2  4
    9  1  3  1
   10  1  3  2
   11  1  3  3
   12  1  3  4
   13  2  1  1
   14  2  1  2
   15  2  1  3
   16  2  1  4
   17  2  2  1
   18  2  2  4
   19  2  3  1
   20  2  3  2
   21  2  3  3
   22  2  3  4
   23  3  1  1
   24  3  1  2
   25  3  1  3
   26  3  1  4
   27  3  2  1
   28  3  2  4
   29  3  3  1
   30  3  3  2
   31  3  3  3
   32  3  3  4
   33  4  1  1
   34  4  1  2
   35  4  1  3
   36  4  1  4
   37  4  2  1
   38  4  2  4
   39  4  3  1
   40  4  3  2
   41  4  3  3
   42  4  3  4
   43  5  1  1
   44  5  1  2
   45  5  1  3
   46  5  1  4
   47  5  2  1
   48  5  2  2
   49  5  2  3
   50  5  2  4
   51  5  3  1
   52  5  3  2
   53  5  3  3
   54  5  3  4

INDEX_BOX2_NEXT_2D_TEST
  INDEX_BOX2_NEXT_2D produces IJ indices that
  lie on the surface of a box2 in 2D.

  The box has half-widths:
     4  3

  and has center cell:
    10 20

     #    I   J

    1  6 17
    2  6 18
    3  6 19
    4  6 20
    5  6 21
    6  6 22
    7  6 23
    8  7 17
    9  7 23
   10  8 17
   11  8 23
   12  9 17
   13  9 23
   14 10 17
   15 10 23
   16 11 17
   17 11 23
   18 12 17
   19 12 23
   20 13 17
   21 13 23
   22 14 17
   23 14 18
   24 14 19
   25 14 20
   26 14 21
   27 14 22
   28 14 23

INDEX_BOX2_NEXT_3D_TEST
  INDEX_BOX2_NEXT_3D produces IJK indices that
  lie on the surface of a box.

  The box has half widths:
     5  3  4

  and central cell:
    10 20 30

  We will only print a PORTION of the data!

   #    I   J   K

    1  5 17 26
    2  5 17 27
    3  5 17 28
    4  5 17 29
    5  5 17 30
    6  5 17 31
    7  5 17 32
    8  5 17 33
    9  5 17 34
   10  5 18 26
  370 15 23 26
  371 15 23 27
  372 15 23 28
  373 15 23 29
  374 15 23 30
  375 15 23 31
  376 15 23 32
  377 15 23 33
  378 15 23 34

INDEX_NEXT0_TEST
  INDEX_NEXT0 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limit.

  Number of index entries =        3
  Coordinate maximum HI =          3

  Index arrays:

     1   1   1
     2   1   1
     3   1   1
     1   2   1
     2   2   1
     3   2   1
     1   3   1
     2   3   1
     3   3   1
     1   1   2
     2   1   2
     3   1   2
     1   2   2
     2   2   2
     3   2   2
     1   3   2
     2   3   2
     3   3   2
     1   1   3
     2   1   3
     3   1   3
     1   2   3
     2   2   3
     3   2   3
     1   3   3
     2   3   3
     3   3   3

INDEX_NEXT1_TEST
  INDEX_NEXT1 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limits.

  Number of index entries =        3

  Coordinate maximum indices:

       1         4
       2         2
       3         3

  Index arrays:

     1   1   1
     2   1   1
     3   1   1
     4   1   1
     1   2   1
     2   2   1
     3   2   1
     4   2   1
     1   1   2
     2   1   2
     3   1   2
     4   1   2
     1   2   2
     2   2   2
     3   2   2
     4   2   2
     1   1   3
     2   1   3
     3   1   3
     4   1   3
     1   2   3
     2   2   3
     3   2   3
     4   2   3

INDEX_NEXT2_TEST
  INDEX_NEXT2 generates all indices of an
  array of given shape with given
  lower and upper limits.

  Number of index entries =        3

  Coordinate, Maximum Index

         1        10        11
         2        -5        -3
         3         0         1

  Index arrays:

    10  -5   0
    11  -5   0
    10  -4   0
    11  -4   0
    10  -3   0
    11  -3   0
    10  -5   1
    11  -5   1
    10  -4   1
    11  -4   1
    10  -3   1
    11  -3   1

INDEX_RANK0_TEST
  INDEX_RANK0 ranks an index with
  lower limit 1 and given upper limit.

  Number of index entries =        3

  Coordinate maximum Index =        3


  The index array:

       1         3
       2         1
       3         2

  The rank of this object is       12

INDEX_RANK1_TEST
  INDEX_RANK1 ranks an index with
  lower limit 1 and given upper limits.

  Number of index entries =        3

  Coordinate, Maximum Index

           1         4
           2         2
           3         3

  The index array:

       1         4
       2         1
       3         2

  The rank of this object is       12

INDEX_RANK2_TEST
  INDEX_RANK2 ranks an index with given
  lower and upper limits.

  Number of index entries =        3

  Coordinate, Minimum index, Maximum Index

           1         1        10
           4         2
           2         1        10
           4        11
           3         1        10
           4         6

  The index array:

       1         1
       2        11
       3         5

  The rank of this object is        7

INDEX_UNRANK0_TEST
  INDEX_UNRANK0 unranks a multi-index.

  The multi-index has dimension        3

  The upper limit is HI =        3

  Rank, Multi-Index:

    1       1       1       1
    2       2       1       1
    3       3       1       1
    4       1       2       1
    5       2       2       1
    6       3       2       1
    7       1       3       1
    8       2       3       1
    9       3       3       1
   10       1       1       2
   11       2       1       2
   12       3       1       2
   13       1       2       2
   14       2       2       2
   15       3       2       2
   16       1       3       2
   17       2       3       2
   18       3       3       2
   19       1       1       3
   20       2       1       3
   21       3       1       3
   22       1       2       3
   23       2       2       3
   24       3       2       3
   25       1       3       3
   26       2       3       3
   27       3       3       3

INDEX_UNRANK1_TEST
  INDEX_UNRANK1 unranks a multi-index.

  The multi-index has dimension        3

  The upper limits are:

           1         4
           2         2
           3         3

  Rank, Multi-Index:

    1       1       1       1
    2       2       1       1
    3       3       1       1
    4       4       1       1
    5       1       2       1
    6       2       2       1
    7       3       2       1
    8       4       2       1
    9       1       1       2
   10       2       1       2
   11       3       1       2
   12       4       1       2
   13       1       2       2
   14       2       2       2
   15       3       2       2
   16       4       2       2
   17       1       1       3
   18       2       1       3
   19       3       1       3
   20       4       1       3
   21       1       2       3
   22       2       2       3
   23       3       2       3
   24       4       2       3

INDEX_UNRANK2_TEST
  INDEX_UNRANK2 unranks a multi-index.

  The multi-index has dimension        3

  The lower and upper limits are:

           1         1         2
           2        10        11
           3         4         6

  Rank, Multi-Index:

    7       1      11       5

INVERSE_MOD_N_TEST
  INVERSE_MOD_N seeks Y, the inverse of B mod N,
  so that mod ( B * Y, N ) = 1, but returns 0
  if the inverse does not exist.

     B     N     Y     Z = mod ( B * Y, N )

     1     2     1     1
     1     3     1     1
     2     3     2     1
     1     4     1     1
     2     4     0     0
     3     4     3     1
     1     5     1     1
     2     5     3     1
     3     5     2     1
     4     5     4     1
     1     6     1     1
     2     6     0     0
     3     6     0     0
     4     6     0     0
     5     6     5     1
     1     7     1     1
     2     7     4     1
     3     7     5     1
     4     7     2     1
     5     7     3     1
     6     7     6     1
     1     8     1     1
     2     8     0     0
     3     8     3     1
     4     8     0     0
     5     8     5     1
     6     8     0     0
     7     8     7     1
     1     9     1     1
     2     9     5     1
     3     9     0     0
     4     9     7     1
     5     9     2     1
     6     9     0     0
     7     9     4     1
     8     9     8     1
     1    10     1     1
     2    10     0     0
     3    10     7     1
     4    10     0     0
     5    10     0     0
     6    10     0     0
     7    10     3     1
     8    10     0     0
     9    10     9     1

INVERSION_TO_PERM1_TEST
  INVERSION_TO_PERM1: inversion => permutation (1,...,N).

    1  2  3  4  5
    3  5  1  4  2
    0  0  2  1  3
    3  5  1  4  2

INVOLUTE_ENUM_TEST
  INVOLUTE_ENUM counts involutions;


         N    Number   Probability

         0         1     1.00000    
         1         1     1.00000    
         2         2     1.00000    
         3         4    0.666667    
         4        10    0.416667    
         5        26    0.216667    
         6        76    0.105556    
         7       232    0.460317E-01
         8       764    0.189484E-01
         9      2620    0.722002E-02
        10      9496    0.261684E-02

JFRAC_TO_RFRAC_TEST
  JFRAC_TO_RFRAC converts a J fraction
  to a rational polynomial fraction.

  The original rational polynomial coefficients:

    0.218418      0.956318      0.829509      0.561695      0.415307    
    0.661187E-01
    0.641848      0.273997      0.109216       1.57976      0.153816    
     1.12019       1.00000    

  The J fraction coefficients:

    0.661187E-01   24.0763     -0.310636       1.40276       5.16789    
   -0.686133E-01
    -5.16104       4.91564     -0.945630      -1.04001       2.91888    
    0.432351    

  The recovered rational polynomial:

    0.218418      0.956318      0.829509      0.561695      0.415307    
    0.661187E-01
    0.641848      0.273997      0.109216       1.57976      0.153816    
     1.12019       1.00000    

JOSEPHUS_TEST
  JOSEPHUS solves Josephus problems.

    N    M    K	 X

     41    3   41   31
     41  -38   41   31
     41    3   40   16
     64    2   64    1
   1000    2 1000  977

KSUB_NEXT_TEST
  KSUB_NEXT generates all K subsets of an N set
  in lexicographic order.

     1       1   2   3
     2       1   2   4
     3       1   2   5
     4       1   3   4
     5       1   3   5
     6       1   4   5
     7       2   3   4
     8       2   3   5
     9       2   4   5
    10       3   4   5

KSUB_NEXT2_TEST
  KSUB_NEXT2 generates the next K subset of an
  N set by the revolving door method.

  Rank  Subset  Added  Removed

     1   1 2 3    0        0
     2   1 3 4    4        2
     3   2 3 4    2        1
     4   1 2 4    1        3
     5   1 4 5    5        2
     6   2 4 5    2        1
     7   3 4 5    3        2
     8   1 3 5    1        4
     9   2 3 5    2        1
    10   1 2 5    1        3

KSUB_NEXT3_TEST
  KSUB_NEXT3 generates all K subsets of an N set
  using the revolving door method.

  Rank    Subset  Added Removed

     1   1 2 3    0        0
     2   1 3 4    4        2
     3   2 3 4    2        1
     4   1 2 4    1        3
     5   1 4 5    5        2
     6   2 4 5    2        1
     7   3 4 5    3        2
     8   1 3 5    1        4
     9   2 3 5    2        1
    10   1 2 5    1        3

KSUB_NEXT4_TEST
  KSUB_NEXT4 generates K subsets of an N set.
  N =        5
  K=         3

  Rank    Subset

     1       1   2   3
     2       1   2   4
     3       1   3   4
     4       2   3   4
     5       1   2   5
     6       1   3   5
     7       2   3   5
     8       1   4   5
     9       2   4   5
    10       3   4   5

KSUB_RANDOM_TEST
  KSUB_RANDOM generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3

    2  4  5
    1  2  4
    1  4  5
    1  4  5
    1  3  4
    3  4  5
    1  2  3
    1  3  4
    1  3  5
    2  3  4

KSUB_RANDOM2_TEST
  KSUB_RANDOM2 generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3

    1  4  5
    1  2  3
    1  3  4
    1  4  5
    1  2  3
    3  4  5
    2  3  5
    2  4  5
    1  2  4
    1  3  5

KSUB_RANDOM3_TEST
  KSUB_RANDOM3 generates a random K-subset of an N-set.
  Set size is N =           5
  Subset size is K =        3

    1  4  5
    1  2  4
    1  4  5
    1  2  3
    2  4  5
    1  2  4
    1  4  5
    1  3  5
    1  4  5
    2  4  5

KSUB_RANDOM4_TEST
  KSUB_RANDOM4 generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3

    1  2  4
    3  4  5
    2  3  4
    1  3  5
    1  2  5
    2  3  5
    2  3  5
    1  4  5
    1  2  5
    1  2  5

KSUB_RANDOM5_TEST
  KSUB_RANDOM5 generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3

    1  2  5
    1  2  3
    1  2  3
    1  2  4
    2  3  5
    1  4  5
    1  2  5
    2  3  5
    2  3  5
    2  3  5

KSUB_RANK_TEST
  KSUB_RANK: rank of a K subset of an N set.

  For N =        5
  and K =        3
  the subset is:
   1   3   5

  The rank is        6

KSUB_TO_COMP_TEST
  COMP_TO_KSUB returns the K subset corresponding to a composition.
  KSUB_TO_COMP returns the composition corresponding to a K subset.

  COMP:   0   4   1   0   5
  KSUB:   1   6   8   9
  COMP:   0   4   1   0   5

  COMP:   1   4   2   0   3
  KSUB:   2   7  10  11
  COMP:   1   4   2   0   3

  COMP:   2   0   2   6   0
  KSUB:   3   4   7  14
  COMP:   2   0   2   6   0

  COMP:   2   2   3   0   3
  KSUB:   3   6  10  11
  COMP:   2   2   3   0   3

  COMP:   1   3   1   5   0
  KSUB:   2   6   8  14
  COMP:   1   3   1   5   0

KSUB_TO_COMPNZ_TEST
  KSUB_TO_COMPNZ returns the nonzero composition
  corresponding to a K subset.

  KSUB:     1   6   8   9
  COMPNZ:   1   5   2   1   6
  KSUB:     1   6   8   9

  KSUB:     2   7  10  11
  COMPNZ:   2   5   3   1   4
  KSUB:     2   7  10  11

  KSUB:     3   4   7  14
  COMPNZ:   3   1   3   7   1
  KSUB:     3   4   7  14

  KSUB:     3   6  10  11
  COMPNZ:   3   3   4   1   4
  KSUB:     3   6  10  11

  KSUB:     2   6   8  14
  COMPNZ:   2   4   2   6   1
  KSUB:     2   6   8  14

KSUB_UNRANK_TEST
  KSUB_UNRANK: find the K-subset of an N set
  of a given rank.

  N is        5
  K is        3
  and the desired rank is        8

  The subset of the given rank is:
     1   4   5

L4VEC_NEXT_TEST
  L4VEC_NEXT generates logical vectors.

  FFF
  FFT
  FTF
  FTT
  TFF
  TFT
  TTF
  TTT

MATRIX_PRODUCT_OPT_TEST
  MATRIX_PRODUCT_OPT seeks the optimal order
  for a chain of matrix products.

  Matrix ranks:

         I         R         C

         1         4         2
         2         2         3
         3         3         1
         4         1         2
         5         2         2
         6         2         3

  Optimal cost is       36

  Ordering:

       1         2
       2         1
       3         4
       4         5
       5         3

MOEBIUS_MATRIX_TEST
  MOEBIUS_MATRIX computes the Moebius matrix.

  The input matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        0      0      0      0      0      1      0      0      0      1
       2        0      0      1      1      0      0      0      0      0      0
       3        1      0      0      0      0      0      0      0      1      0
       4        1      0      0      0      1      0      0      0      1      0
       5        0      0      0      0      0      1      0      0      0      0
       6        0      0      0      0      0      0      1      0      0      0
       7        0      0      0      0      0      0      0      0      0      0
       8        0      1      0      0      0      0      0      0      0      0
       9        0      0      0      0      0      1      0      0      0      1
      10        0      0      0      0      0      0      1      0      0      0
      11        0      0      0      0      0      0      1      0      0      0

  Col        11
  Row

       1        0
       2        0
       3        0
       4        0
       5        0
       6        0
       7        0
       8        0
       9        1
      10        0
      11        0

  The Moebius matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        1      0      0      0      0     -1      1      0      0     -1
       2        1      1     -1     -1      0     -1      1      0      1     -1
       3       -1      0      1      0      0      1     -1      0     -1      1
       4       -1      0      0      1     -1      2     -1      0     -1      1
       5        0      0      0      0      1     -1      0      0      0      0
       6        0      0      0      0      0      1     -1      0      0      0
       7        0      0      0      0      0      0      1      0      0      0
       8        0     -1      0      0      0      0      0      1      0      0
       9        0      0      0      0      0     -1      2      0      1     -1
      10        0      0      0      0      0      0     -1      0      0      1
      11        0      0      0      0      0      0     -1      0      0      0

  Col        11
  Row

       1        0
       2        0
       3        0
       4        0
       5        0
       6        0
       7        0
       8        0
       9       -1
      10        0
      11        1

MONOMIAL_COUNT_TEST
  MONOMIAL_COUNT counts the number of monomials of
  degrees 0 through DEGREE_MAX in a space of dimension DIM.

  DIM    Count

     1        10
     2        55
     3       220
     4       715
     5      2002
     6      5005

MONOMIAL_COUNTS_TEST
  MONOMIAL_COUNTS counts the number of monomials of
  each degree 0 through DEGREE_MAX in a space of dimension DIM.

  DIM =        1

         0         1
         1         1
         2         1
         3         1
         4         1
         5         1
         6         1
         7         1
         8         1
         9         1

     Total        10

  DIM =        2

         0         1
         1         2
         2         3
         3         4
         4         5
         5         6
         6         7
         7         8
         8         9
         9        10

     Total        55

  DIM =        3

         0         1
         1         3
         2         6
         3        10
         4        15
         5        21
         6        28
         7        36
         8        45
         9        55

     Total       220

  DIM =        4

         0         1
         1         4
         2        10
         3        20
         4        35
         5        56
         6        84
         7       120
         8       165
         9       220

     Total       715

  DIM =        5

         0         1
         1         5
         2        15
         3        35
         4        70
         5       126
         6       210
         7       330
         8       495
         9       715

     Total      2002

  DIM =        6

         0         1
         1         6
         2        21
         3        56
         4       126
         5       252
         6       462
         7       792
         8      1287
         9      2002

     Total      5005

MORSE_THUE_TEST
  MORSE_THUE computes the Morse-Thue numbers.

    0110100110
    0101101001
    0110011010
    0110010110
    0110100101
    1010011001
    0110100101
    1001101001
    0110100110
    0101100110
    1

MULTINOMIAL_COEF1_TEST
  MULTINOMIAL_COEF1 computes multinomial
  coefficients using the Gamma function;

  Line 10 of the BINOMIAL table:

     0  10       1
     1   9      10
     2   8      45
     3   7     120
     4   6     210
     5   5     252
     6   4     210
     7   3     120
     8   2      45
     9   1      10
    10   0       1

  Level 5 of the TRINOMIAL coefficients:

     0   0   5       1
     0   1   4       5
     0   2   3      10
     0   3   2      10
     0   4   1       5
     0   5   0       1

     1   0   4       5
     1   1   3      20
     1   2   2      30
     1   3   1      20
     1   4   0       5

     2   0   3      10
     2   1   2      30
     2   2   1      30
     2   3   0      10

     3   0   2      10
     3   1   1      20
     3   2   0      10

     4   0   1       5
     4   1   0       5

     5   0   0       1

MULTINOMIAL_COEF2_TEST
  MULTINOMIAL_COEF2 computes multinomial
  coefficients directly.

  Line 10 of the BINOMIAL table:

     0  10       1
     1   9      10
     2   8      45
     3   7     120
     4   6     210
     5   5     252
     6   4     210
     7   3     120
     8   2      45
     9   1      10
    10   0       1

  Level 5 of the TRINOMIAL coefficients:

     0   0   5       1
     0   1   4       5
     0   2   3      10
     0   3   2      10
     0   4   1       5
     0   5   0       1

     1   0   4       5
     1   1   3      20
     1   2   2      30
     1   3   1      20
     1   4   0       5

     2   0   3      10
     2   1   2      30
     2   2   1      30
     2   3   0      10

     3   0   2      10
     3   1   1      20
     3   2   0      10

     4   0   1       5
     4   1   0       5

     5   0   0       1

MULTIPERM_ENUM_TEST
  MULTIPERM_ENUM enumerates multipermutations.

  N is the number of objects to be permuted.
  K is the number of distinct types of objects.
  COUNTS is the number of objects of each type.
  NUMBER is the number of multipermutations.

  Number       N       K       Counts(1:K)

       5       5       2     4     1
       1       5       1     5
       5       5       2     1     4
       1       5       1     5
      60       5       4     1     1     1     2

MULTIPERM_NEXT_TEST
  MULTIPERM_NEXT computes multipermutations in
  lexical order.

     1     1   2   2   3   3   3
     2     1   2   3   2   3   3
     3     1   2   3   3   2   3
     4     1   2   3   3   3   2
     5     1   3   2   2   3   3
     6     1   3   2   3   2   3
     7     1   3   2   3   3   2
     8     1   3   3   2   2   3
     9     1   3   3   2   3   2
    10     1   3   3   3   2   2
    11     2   1   2   3   3   3
    12     2   1   3   2   3   3
    13     2   1   3   3   2   3
    14     2   1   3   3   3   2
    15     2   2   1   3   3   3
    16     2   2   3   1   3   3
    17     2   2   3   3   1   3
    18     2   2   3   3   3   1
    19     2   3   1   2   3   3
    20     2   3   1   3   2   3
    21     2   3   1   3   3   2
    22     2   3   2   1   3   3
    23     2   3   2   3   1   3
    24     2   3   2   3   3   1
    25     2   3   3   1   2   3
    26     2   3   3   1   3   2
    27     2   3   3   2   1   3
    28     2   3   3   2   3   1
    29     2   3   3   3   1   2
    30     2   3   3   3   2   1
    31     3   1   2   2   3   3
    32     3   1   2   3   2   3
    33     3   1   2   3   3   2
    34     3   1   3   2   2   3
    35     3   1   3   2   3   2
    36     3   1   3   3   2   2
    37     3   2   1   2   3   3
    38     3   2   1   3   2   3
    39     3   2   1   3   3   2
    40     3   2   2   1   3   3
    41     3   2   2   3   1   3
    42     3   2   2   3   3   1
    43     3   2   3   1   2   3
    44     3   2   3   1   3   2
    45     3   2   3   2   1   3
    46     3   2   3   2   3   1
    47     3   2   3   3   1   2
    48     3   2   3   3   2   1
    49     3   3   1   2   2   3
    50     3   3   1   2   3   2
    51     3   3   1   3   2   2
    52     3   3   2   1   2   3
    53     3   3   2   1   3   2
    54     3   3   2   2   1   3
    55     3   3   2   2   3   1
    56     3   3   2   3   1   2
    57     3   3   2   3   2   1
    58     3   3   3   1   2   2
    59     3   3   3   2   1   2
    60     3   3   3   2   2   1

NETWORK_FLOW_MAX_TEST
  NETWORK_FLOW_MAX finds the maximum flow on a network.

  The source is node        1
  The sink is node          6

  Endpoint array:

    1  1  2  2  2  3  3  4  4  5  2  3  3  4  5  4  5  5  6  6
    2  3  3  4  5  4  5  5  6  6  1  1  2  2  2  3  3  4  4  5

  Input edge capacity array:

    3  7  2  5  4  1  4  2  8  3  0  0  0  0  0  0  0  0  0  0

  Reordered endpoint array:

    1  1  2  2  2  2  3  3  3  3  4  4  4  4  5  5  5  5  6  6
    2  3  1  3  4  5  1  2  4  5  2  3  5  6  2  3  4  6  4  5

  Output edge capacity/flow array:

    3  7  0  2  5  4  0  0  1  4  0  0  2  8  0  0  0  3  0  0
    3  4 -3  0  3  0 -4  0  1  3 -3 -1  0  4  0 -3  0  3 -4 -3

  Minimal node cut vector:

       1         1
       2         0
       3         1
       4         0
       5         1
       6         0

  Nodal flow vector:

       1         7
       2         3
       3         4
       4         4
       5         3
       6         7

NIM_SUM_TEST
  NIM_SUM computes the Nim sum of two integers.

    I    J    Nim(I+J)


  I1, I2, I3 in decimal:

  218
  957
  871

  I1, I2, I3 in binary:

  00000000000000000000000011011010
  00000000000000000000001110111101
  00000000000000000000001101100111

  I1, I2, I3 in decimal:

  830
  562
  268

  I1, I2, I3 in binary:

  00000000000000000000001100111110
  00000000000000000000001000110010
  00000000000000000000000100001100

  I1, I2, I3 in decimal:

  415
   66
  477

  I1, I2, I3 in binary:

  00000000000000000000000110011111
  00000000000000000000000001000010
  00000000000000000000000111011101

  I1, I2, I3 in decimal:

  257
  110
  367

  I1, I2, I3 in binary:

  00000000000000000000000100000001
  00000000000000000000000001101110
  00000000000000000000000101101111

  I1, I2, I3 in decimal:

   43
  634
  593

  I1, I2, I3 in binary:

  00000000000000000000000000101011
  00000000000000000000001001111010
  00000000000000000000001001010001

PADOVAN_TEST
  PADOVAN computes the Padovan numbers.


       N        P(N)

         0           1
         1           1
         2           1
         3           2
         4           2
         5           3
         6           4
         7           5
         8           7
         9           9
        10          12
        11          16
        12          21
        13          28
        14          37

PELL_BASIC_TEST
  PELL_BASIC solves the basic Pell equation.

       D       X        Y         R

          2        3        2        1
          3        2        1        1
          5        9        4        1
          6        5        2        1
          7        8        3        1
          8        3        1        1
         10       19        6        1
         11       10        3        1
         12        7        2        1
         13      649      180        1
         14       15        4        1
         15        4        1        1
         17       33        8        1
         18       17        4        1
         19      170       39        1
         20        9        2        1

PELL_NEXT_TEST
  PELL_NEXT computes the "next" solution of the Pell equation.

       D       X        Y         R

          2        3        2        1
                  17       12        1
          3        2        1        1
                   7        4        1
          5        9        4        1
                 161       72        1
          6        5        2        1
                  49       20        1
          7        8        3        1
                 127       48        1
          8        3        1        1
                  17        6        1
         10       19        6        1
                 721      228        1
         11       10        3        1
                 199       60        1
         12        7        2        1
                  97       28        1
         13      649      180        1
              842401   233640        1
         14       15        4        1
                 449      120        1
         15        4        1        1
                  31        8        1
         17       33        8        1
                2177      528        1
         18       17        4        1
                 577      136        1
         19      170       39        1
               57799    13260        1
         20        9        2        1
                 161       36        1

PENT_ENUM_TEST
  PENT_ENUM counts points in pentagons.


  N    Pent(N)

           0         0
           1         1
           2         5
           3        12
           4        22
           5        35
           6        51
           7        70
           8        92
           9       117
          10       145

PERM_ASCEND_TEST
  PERM_ASCEND determines the length of the longest
  increasing subsequence in a permutation.

  The permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The length of the longest increasing subsequence is        5

  A longest increasing subsequence:

       1         2
       2         3
       3         6
       4         7
       5         8

PERM_FIXED_ENUM_TEST
  PERM_FIXED_ENUM enumerates the permutations
  of N objects that leave M unchanged.

  For this test, N =       10

  M    F(N,M)

    0   1334961
    1   1334960
    2    667485
    3    222480
    4     55650
    5     11088
    6      1890
    7       240
    8        45
    9         0
   10         1

PERM0_CHECK_TEST
  PERM0_CHECK checks a permutation of 0,...,N-1.


  Permutation 1:

     0   1   2   3   4
     5   2   3   4   1

PERM0_CHECK - Fatal error!
  Permutation is missing value    0

  Permutation 2:

     0   1   2   3   4
     4   1   3   0   2

  Permutation 3:

     0   1   2   3   4
     0   2   1   3   2

PERM0_CHECK - Fatal error!
  Permutation is missing value    4

PERM0_PRINT_TEST
  PERM0_PRINT prints a permutation.

  The 0-based permutation:

     0   1   2   3   4   5   6
     6   1   3   0   4   2   5

PERM1_BREAK_COUNT_TEST
  PERM1_BREAK_COUNT counts breaks in a permutation of (1,...,N).

  The permutation:

     1   2   3   4   5   6
     4   5   2   1   6   3

  The number of breaks is        5

PERM1_CANON_TO_CYCLE_TEST
  PERM1_CANON_TO_CYCLE converts a permutation of (1,...,N) from
  canonical to cycle form.

  The permutation in canonical form:

     1   2   3   4   5   6
     4   5   2   1   6   3

  The permutation in cycle form:

     1   2   3   4   5   6
    -4   5  -2  -1   6   3

PERM1_CHECK_TEST
  PERM1_CHECK checks a permutation of (1,...,N).


  Permutation 1:

     1   2   3   4   5
     5   2   3   4   1

  Permutation 2:

     1   2   3   4   5
     4   1   3   0   2

PERM1_CHECK - Fatal error!
  Permutation is missing value    5

  Permutation 3:

     1   2   3   4   5
     0   2   1   3   2

PERM1_CHECK - Fatal error!
  Permutation is missing value    4

PERM1_CYCLE_TEST
  PERM1_CYCLE analyzes a permutation of (1,...,N).

  The permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  NCYCLE =        3
  ISGN =          1

  The permutation in cycle form:

     1   2   3   4   5   6   7   8   9
    -2   3   9  -6  -7   8   5   4   1

PERM1_CYCLE_TO_CANON_TEST
  PERM1_CYCLE_TO_CANON converts a permutation of (1,...,N) from
  cycle to canonical form.

  The permutation in cycle form:

     1   2   3   4   5   6
    -6   3   1  -5   4  -2

  The permutation in canonical form:

     1   2   3   4   5   6
     4   5   2   1   6   3

PERM1_CYCLE_TO_INDEX_TEST
  PERM1_CYCLE_TO_INDEX converts a permutation of (1,...,N) from
  cycle to standard index form.

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permutation in cycle form:

     1   2   3   4   5   6   7   8   9
    -1   2   3   9  -4   6   8  -5   7

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

PERM1_DISTANCE_TEST
  PERM1_DISTANCE computes the Ulam metric distance
  between two permutations of (1,...,N).

  Permutation P1

     1   2   3   4   5   6   7   8   9  10
     4   3   2  10   1   7   9   6   8   5

  Permutation P2

     1   2   3   4   5   6   7   8   9  10
     9   3   5   7   8   6   1   4  10   2

  Permutation P3

     1   2   3   4   5   6   7   8   9  10
     2   4   1   3   8   6   9   7  10   5

  K(P1,P1) should be 0.

  K(P1,P1) =        0

  K(P1,P2) should equal K(P2,P1).

  K(P1,P2) =        7
  K(P2,P1) =        7

  K(P1,P3) <= K(P1,P2) + K(P2,P3).

  K(P1,P3) =        6
  K(P1,P2) =        7
  K(P2,P3) =        6
  K(P1,P2) + K(P2,P3) =       13

PERM1_FREE_TEST
  PERM1_FREE returns the unused values in a partial permutation of (1,...,N).
 
  Partial permutation:
  (empty vector)
 
  Values not yet used:
           1           2           3           4           5
 
  Partial permutation:
           5
 
  Values not yet used:
           1           2           3           4
 
  Partial permutation:
           5           2
 
  Values not yet used:
           1           3           4
 
  Partial permutation:
           5           2           3
 
  Values not yet used:
           1           4
 
  Partial permutation:
           5           2           3           4
 
  Values not yet used:
           1
 
  Partial permutation:
           5           2           3           4           1
 
  Values not yet used:
  (empty vector)

PERM1_INDEX_TO_CYCLE_TEST
  PERM1_INDEX_TO_CYCLE converts a permutation of (1,...,N) from
  standard index to cycle form.

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permutation in cycle form:

     1   2   3   4   5   6   7   8   9
    -1   2   3   9  -4   6   8  -5   7

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

PERM1_INVERSE_TEST
  PERM1_INVERSE inverts a permutation of (1,...,N)


  The original permutation:

     1   2   3   4   5   6   7
     4   3   5   1   7   6   2

  The inverted permutation:

     1   2   3   4   5   6   7
     4   7   2   1   3   6   5

PERM1_INVERSE2_TEST
  PERM1_INVERSE2 inverts a permutation of (1,...,N).

  The original permutation:

     1   2   3   4   5   6   7
     4   3   5   1   7   6   2

  The inverted permutation:

     1   2   3   4   5   6   7
     4   7   2   1   3   6   5

PERM1_INVERSE3_TEST
  PERM1_INVERSE3 inverts a permutation of (1,...,N).

  The original permutation:

     1   2   3   4   5   6   7
     4   3   5   1   7   6   2

  The inverted permutation:

     1   2   3   4   5   6   7
     4   7   2   1   3   6   5

PERM1_LEX_NEXT_TEST
  PERM1_LEX_NEXT generates permutations of (1,...,N).

     1   2   3   4
     1   2   4   3
     1   3   2   4
     1   3   4   2
     1   4   2   3
     1   4   3   2
     2   1   3   4
     2   1   4   3
     2   3   1   4
     2   3   4   1
     2   4   1   3
     2   4   3   1
     3   1   2   4
     3   1   4   2
     3   2   1   4
     3   2   4   1
     3   4   1   2
     3   4   2   1
     4   1   2   3
     4   1   3   2
     4   2   1   3
     4   2   3   1
     4   3   1   2
     4   3   2   1

PERM1_MUL_TEST
  PERM1_MUL multiplies two permutations of (1,...,N).


  Permutation P1:

     1   2   3   4   5
     2   5   1   3   4

  Permutation P2:

     1   2   3   4   5
     3   2   1   4   5

  Product permutation:

     1   2   3   4   5
     2   5   3   1   4

PERM1_NEXT_TEST
  PERM1_NEXT generates permutations of (1,...,N).

     1   2   3   4
     2   1   3   4
     3   1   2   4
     1   3   2   4
     2   3   1   4
     3   2   1   4
     4   2   1   3
     2   4   1   3
     1   4   2   3
     4   1   2   3
     2   1   4   3
     1   2   4   3
     1   3   4   2
     3   1   4   2
     4   1   3   2
     1   4   3   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     2   4   3   1
     4   2   3   1
     3   2   4   1
     2   3   4   1

PERM1_NEXT2_TEST
  PERM1_NEXT2 generates permutations of (1,...,N).

     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4

PERM1_NEXT3_TEST
  PERM1_NEXT3 generates permutations of (1,...,N).

     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4

PERM1_PRINT_TEST
  PERM1_PRINT prints a permutation of (1,...,N).

  The 1-based permutation:

     1   2   3   4   5   6   7
     7   2   4   1   5   3   6

PERM1_RANDOM_TEST
  PERM1_RANDOM produces a random permutation of (1,...,N);
  For this test, N =        4

     1   4   2   3
     3   1   2   4
     2   1   3   4
     3   2   1   4
     2   4   1   3

PERM1_RANDOM2_TEST
  PERM1_RANDOM2 produces a random permutation of (1,...,N).
  For this test, N =        4

     2   1   4   3
     4   1   3   2
     1   3   4   2
     4   2   1   3
     3   4   2   1

PERM1_RANK_TEST
  PERM1_RANK ranks a permutation of (1,...,N).

  The permutation:

     1   2   3   4
     1   4   2   3

  The rank is:       3

PERM1_SIGN_TEST
  PERM1_SIGN computes the sign of a permutation of (1,...,N).

  RANK  SIGN  Permutation

     0     1     1   2   3   4
     1    -1     1   2   4   3
     2    -1     1   3   2   4
     3     1     1   3   4   2
     4     1     1   4   2   3
     5    -1     1   4   3   2
     6    -1     2   1   3   4
     7     1     2   1   4   3
     8     1     2   3   1   4
     9    -1     2   3   4   1
    10    -1     2   4   1   3
    11     1     2   4   3   1
    12     1     3   1   2   4
    13    -1     3   1   4   2
    14    -1     3   2   1   4
    15     1     3   2   4   1
    16     1     3   4   1   2
    17    -1     3   4   2   1
    18    -1     4   1   2   3
    19     1     4   1   3   2
    20     1     4   2   1   3
    21    -1     4   2   3   1
    22    -1     4   3   1   2
    23     1     4   3   2   1

PERM1_TO_EQUIV_TEST
  PERM1_TO_EQUIV returns the set partition
  or equivalence classes determined by a
  permutation of (1,...,N).

  The input permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The partition:

   Set  Size
       1       4 ::    1   2   3   9
       2       3 ::    4   6   8
       3       2 ::    5   7

PERM1_TO_INVERSION_TEST
  PERM1_TO_INVERSION: permutation (1,...,N) => inversion.

    1  2  3  4  5
    3  5  1  4  2
    0  0  2  1  3
    3  5  1  4  2

PERM1_TO_YTB_TEST
  PERM1_TO_YTB converts a permutation of (1,...,N) to a
  Young table.

  The permutation:

     1   2   3   4   5   6   7
     7   2   4   1   5   3   6

  The Young table:

   1   3   5   6
   2   4
   7

PERM1_UNRANK_TEST
  PERM1_UNRANK, given a rank, computes the
  corresponding permutation of (1,...,N).

  The requested rank is        6

  The permutation:

     1   2   3   4
     1   4   3   2

PERRIN_TEST
  PERRIN computes the Perrin numbers.

     N        P(N)

         0         3
         1         0
         2         2
         3         3
         4         2
         5         5
         6         5
         7         7
         8        10
         9        12
        10        17
        11        22
        12        29
        13        39
        14        51

PORD_CHECK_TEST
  PORD_CHECK checks a partial ordering.

  The partial ordering matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        1      0      0      0      0      0      0      0      0      0
       2        0      1      0      1      0      1      0      1      0      0
       3        1      0      1      1      0      0      0      0      0      0
       4        0      0      0      1      0      0      0      0      0      0
       5        1      1      1      1      1      1      1      1      0      1
       6        0      0      0      1      0      1      0      1      0      0
       7        1      0      1      1      0      1      1      1      0      1
       8        0      0      0      1      0      0      0      1      0      0
       9        0      0      0      0      0      0      0      0      0      0
      10        1      0      1      1      0      0      0      1      0      1

  CHECK FLAG =    0
  0 means no error.
  1 means illegal value of N.
  2 means some A(I,J) and A(J,I) are both nonzero.

POWER_MOD_TEST
  POWER_MOD computes the remainder of a power
  of an integer modulo another integer.

  A =        7
  N =       50
  M =       11
  mod ( A**N, M ) =        1

  A =        3
  N =      118
  M =      119
  mod ( A**N, M ) =       32

POWER_SERIES1_TEST
  POWER_SERIES1 composes a power series;

  Power series of G(x) = (1+F(x))**alpha

  N =       10
  ALPHA =    7.00000    

  Series for F(x):

     1.00000       0.00000       0.00000       0.00000       0.00000    
     0.00000       0.00000       0.00000       0.00000       0.00000    
  Series for G(x):

     7.00000       21.0000       35.0000       35.0000       21.0000    
     7.00000       1.00000       0.00000       0.00000       0.00000    

POWER_SERIES2_TEST
  POWER_SERIES2 composes a power series;
  Here we compute the power series of G(x) = exp(F(x))-1
  The number of terms is N =        4

  Series for F(x):

    -4.00000       0.00000       0.00000       0.00000    

  Series for G(x):

    -4.00000       8.00000      -10.6667       10.6667    

POWER_SERIES3_TEST
  POWER_SERIES3 composes a power series;

  Power series of H(x) = G(F(x))

  Number of terms, N =        4

  Series for F(x):

     1.00000       1.00000       0.00000       0.00000    

  Series for G(x):

     1.00000       1.00000       0.00000       0.00000    

  Series for H(x):

     1.00000       2.00000       2.00000       3.00000    

POWER_SERIES4_TEST
  POWER_SERIES4 composes a power series;

  Power series of H(x) = G(1/F(x))

  N =       10

  Series for F(x):

     1.00000      0.500000      0.333333      0.250000      0.200000    
    0.166667      0.142857      0.125000      0.111111      0.100000    

  Series for G(x):

     1.00000       0.00000       0.00000       0.00000       0.00000    
     0.00000       0.00000       0.00000       0.00000       0.00000    

  Series for H(x):

     1.00000     -0.500000      0.166667     -0.416667E-01  0.833333E-02
   -0.138889E-02  0.198413E-03 -0.248016E-04  0.275573E-05 -0.275573E-06

PRIME_TEST
  PRIME returns primes from a table.

  Number of primes stored is   1600

     I    Prime(I)

       1       2
       2       3
       3       5
       4       7
       5      11
       6      13
       7      17
       8      19
       9      23
      10      29

    1590   13411
    1591   13417
    1592   13421
    1593   13441
    1594   13451
    1595   13457
    1596   13463
    1597   13469
    1598   13477
    1599   13487
    1600   13499

PYTHAG_TRIPLE_NEXT_TEST
  PYTHAG_TRIPLE_NEXT computes the "next"
  Pythagorean triple.

   I   J   A   B   C  A^2+B^2   C^2

     2   1   3   4   5      25      25
     3   2   5  12  13     169     169
     4   1  15   8  17     289     289
     4   3   7  24  25     625     625
     5   2  21  20  29     841     841
     5   4   9  40  41    1681    1681
     6   1  35  12  37    1369    1369
     6   3  27  36  45    2025    2025
     6   5  11  60  61    3721    3721
     7   2  45  28  53    2809    2809
     7   4  33  56  65    4225    4225
     7   6  13  84  85    7225    7225
     8   1  63  16  65    4225    4225
     8   3  55  48  73    5329    5329
     8   5  39  80  89    7921    7921
     8   7  15 112 113   12769   12769
     9   2  77  36  85    7225    7225
     9   4  65  72  97    9409    9409
     9   6  45 108 117   13689   13689
     9   8  17 144 145   21025   21025
    10   1  99  20 101   10201   10201

R8_AGM_TEST
  R8_AGM computes the arithmetic-geometric mean (AGM)
  of two nonnegative real numbers.

    X        Y    R8_AGM(X,Y)

    3.0000   10.0000    5.9777
    9.0000    6.0000    7.4240
    5.0000    1.0000    2.6040
    3.0000    2.0000    2.4747
    1.0000    7.0000    3.2879
    1.0000    5.0000    2.6040
    5.0000    8.0000    6.4120
    8.0000    1.0000    3.6158
    9.0000    4.0000    6.2475
    1.0000    1.0000    1.0000

R8_CHOOSE_TEST
  R8_CHOOSE evaluates C(N,K).

       N         K    CNK

         0         0   1.00000    
         1         0   1.00000    
         1         1   1.00000    
         2         0   1.00000    
         2         1   2.00000    
         2         2   1.00000    
         3         0   1.00000    
         3         1   3.00000    
         3         2   3.00000    
         3         3   1.00000    
         4         0   1.00000    
         4         1   4.00000    
         4         2   6.00000    
         4         3   4.00000    
         4         4   1.00000    

R8_FALL_TEST
  R8_FALL computes the falling factorial function.

    X          N                Exact                  Computed

    5.0000     4     120.0000000000000         120.0000000000000    
    5.2500     4     163.1601562500000         163.1601562500000    
    5.5000     4     216.5625000000000         216.5625000000000    
    5.7500     4     281.6601562500000         281.6601562500000    
    6.0000     4     360.0000000000000         360.0000000000000    
    7.5000     0     1.000000000000000         1.000000000000000    
    7.5000     1     7.500000000000000         7.500000000000000    
    7.5000     2     48.75000000000000         48.75000000000000    
    7.5000     3     268.1250000000000         268.1250000000000    
    7.5000     4     1206.562500000000         1206.562500000000    
    7.5000     5     4222.968750000000         4222.968750000000    
    7.5000     6     10557.42187500000         10557.42187500000    
    7.5000     7     15836.13281250000         15836.13281250000    
    7.5000     8     7918.066406250000         7918.066406250000    
    7.5000     9    -3959.033203125000        -3959.033203125000    

R8_RISE_TEST
  R8_RISE computes the rising factorial function.

    X          N                Exact                  Computed

    5.0000     4     1680.000000000000         1680.000000000000    
    5.2500     4     1962.597656250000         1962.597656250000    
    5.5000     4     2279.062500000000         2279.062500000000    
    5.7500     4     2631.972656250000         2631.972656250000    
    6.0000     4     3024.000000000000         3024.000000000000    
    7.5000     0     1.000000000000000         1.000000000000000    
    7.5000     1     7.500000000000000         7.500000000000000    
    7.5000     2     63.75000000000000         63.75000000000000    
    7.5000     3     605.6250000000000         605.6250000000000    
    7.5000     4     6359.062500000000         6359.062500000000    
    7.5000     5     73129.21875000000         73129.21875000000    
    7.5000     6     914115.2343750000         914115.2343750000    
    7.5000     7     12340555.66406250         12340555.66406250    
    7.5000     8     178938057.1289063         178938057.1289062    
    7.5000     9     2773539885.498047         2773539885.498047    

R8_TO_CFRAC_TEST
  R8_TO_CFRAC converts a real number to a
  a sequence of continued fraction convergents.

  Use the real number R =    6.28319    

             6           6           1   6.00000      0.283185    
             3          19           3   6.33333     -0.501480E-01
             1          25           4   6.25000      0.331853E-01
             1          44           7   6.28571     -0.252898E-02
             7         333          53   6.28302      0.166439E-03
             2         710         113   6.28319     -0.533528E-06
           146      103993       16551   6.28319      0.115578E-08
             3      312689       49766   6.28319     -0.582867E-10
             6     1980127      315147   6.28319      0.547384E-11
             1     2292816      364913   6.28319     -0.322142E-11
             1     4272943      680060   6.28319      0.808242E-12

R8_TO_DEC_TEST
  R8_TO_DEC converts a real number to a decimal;

  The number of decimal digits is   5

     R   =>  A * 10^B  =>  R2

   -5.631634    -56316        -4   -5.631600
    9.126352     91264        -4    9.126400
    6.590185     65902        -4    6.590200
    1.233909     12339        -4    1.233900
   -1.693858    -16939        -4   -1.693900
   -8.677625    -86776        -4   -8.677600
   -4.848444    -48484        -4   -4.848400
   -7.800864    -78009        -4   -7.800900
   -9.123420    -91234        -4   -9.123400
    2.679314     26793        -4    2.679300

R8_TO_RAT_TEST
  R8_TO_RAT converts a real number to a rational;

  The maximum number of digits allowed is   4

     R   =>  A / B  =>  R2

   -0.315817   -1579      5000 -0.315800
    7.063176    8829      1250  7.063200
    5.795092   57951     10000  5.795100
    3.116954    3117      1000  3.117000
    1.653071   16531     10000  1.653100
   -1.838813   -4597      2500 -1.838800
    0.075778     379      5000  0.075800
   -1.400432   -3501      2500 -1.400400
   -2.061710  -20617     10000 -2.061700
    3.839657   38397     10000  3.839700

R8MAT_DET_TEST
  R8MAT_DET: determinant of a real matrix.


  The 123/456/789 matrix:

  Col         1             2             3       
  Row

    1       1.            2.            3.      
    2       4.            5.            6.      
    3       7.            8.            9.      

  Determinant of the 123/456/789 matrix is    0.00000    

  The Hilbert matrix:

  Col         1             2             3             4       
  Row

    1   0.500000      0.333333      0.250000      0.200000    
    2   0.333333      0.250000      0.200000      0.166667    
    3   0.250000      0.200000      0.166667      0.142857    
    4   0.200000      0.166667      0.142857      0.125000    

  Determinant of the Hilbert matrix is   0.236206E-08

  The -1,2,-1 matrix:

  Col         1             2             3       
  Row

    1       2.           -1.            0.      
    2      -1.            2.           -1.      
    3       0.           -1.            2.      

  Determinant of the -1,2,-1 matrix is    4.00000    

R8MAT_PERM1_TEST
  R8MAT_PERM1 reorders a real matrix in place.
  The rows and columns use the same permutation.

  The original matrix

  Col         1             2             3             4             5       
  Row

    1      11.           12.           13.           14.           15.      
    2      21.           22.           23.           24.           25.      
    3      31.           32.           33.           34.           35.      
    4      41.           42.           43.           44.           45.      
    5      51.           52.           53.           54.           55.      
    6      61.           62.           63.           64.           65.      
    7      71.           72.           73.           74.           75.      
    8      81.           82.           83.           84.           85.      
    9      91.           92.           93.           94.           95.      

  Col         6             7             8             9       
  Row

    1      16.           17.           18.           19.      
    2      26.           27.           28.           29.      
    3      36.           37.           38.           39.      
    4      46.           47.           48.           49.      
    5      56.           57.           58.           59.      
    6      66.           67.           68.           69.      
    7      76.           77.           78.           79.      
    8      86.           87.           88.           89.      
    9      96.           97.           98.           99.      

  The row and column permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permuted matrix

  Col         1             2             3             4             5       
  Row

    1      99.           91.           92.           98.           97.      
    2      19.           11.           12.           18.           17.      
    3      29.           21.           22.           28.           27.      
    4      89.           81.           82.           88.           87.      
    5      79.           71.           72.           78.           77.      
    6      49.           41.           42.           48.           47.      
    7      59.           51.           52.           58.           57.      
    8      69.           61.           62.           68.           67.      
    9      39.           31.           32.           38.           37.      

  Col         6             7             8             9       
  Row

    1      94.           95.           96.           93.      
    2      14.           15.           16.           13.      
    3      24.           25.           26.           23.      
    4      84.           85.           86.           83.      
    5      74.           75.           76.           73.      
    6      44.           45.           46.           43.      
    7      54.           55.           56.           53.      
    8      64.           65.           66.           63.      
    9      34.           35.           36.           33.      

R8MAT_2PERM1_TEST
  R8MAT_2PERM1 reorders a real matrix in place.
  Rows and columns use different permutations.

  The original matrix

  Col         1             2             3             4             5       
  Row

    1      11.           12.           13.           14.           15.      
    2      21.           22.           23.           24.           25.      
    3      31.           32.           33.           34.           35.      
    4      41.           42.           43.           44.           45.      
    5      51.           52.           53.           54.           55.      
    6      61.           62.           63.           64.           65.      
    7      71.           72.           73.           74.           75.      
    8      81.           82.           83.           84.           85.      
    9      91.           92.           93.           94.           95.      

  Col         6             7       
  Row

    1      16.           17.      
    2      26.           27.      
    3      36.           37.      
    4      46.           47.      
    5      56.           57.      
    6      66.           67.      
    7      76.           77.      
    8      86.           87.      
    9      96.           97.      

  The row permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The column permutation:

     1   2   3   4   5   6   7
     3   4   5   6   7   1   2

  The permuted matrix

  Col         1             2             3             4             5       
  Row

    1      96.           97.           91.           92.           93.      
    2      16.           17.           11.           12.           13.      
    3      26.           27.           21.           22.           23.      
    4      86.           87.           81.           82.           83.      
    5      76.           77.           71.           72.           73.      
    6      46.           47.           41.           42.           43.      
    7      56.           57.           51.           52.           53.      
    8      66.           67.           61.           62.           63.      
    9      36.           37.           31.           32.           33.      

  Col         6             7       
  Row

    1      94.           95.      
    2      14.           15.      
    3      24.           25.      
    4      84.           85.      
    5      74.           75.      
    6      44.           45.      
    7      54.           55.      
    8      64.           65.      
    9      34.           35.      

R8MAT_PERMANENT_TEST
  R8MAT_PERMANENT: the matrix permanent function.
  We will analyze matrices with 0 diagonal and
  1 on all offdiagonals.

  Order	    Permanent.

        2           1.000000000    
        3           2.000000000    
        4           9.000000000    
        5           44.00000000    
        6           265.0000000    
        7           1854.000000    
        8           14833.00000    
        9           133496.0000    
       10           1334961.000    
       11           14684570.00    
       12           176214841.0    

R8POLY_TEST
  R8POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial

  All calls have input A as follows
     0.00   0.00   0.00   0.00   0.00   1.00

  Option IOPT =       -3
  Output array = 
     0.00  24.00 -50.00  35.00 -10.00   1.00

  Option IOPT =       -2
  Output array = 
     0.00   1.00  15.00  25.00  10.00   1.00

  Option IOPT =       -1
  X0 =    2.00000    
  Value =    0.00000    

  Option IOPT =        0
  X0 =    2.00000    
  Value =    32.0000    

  Option IOPT =        6
  X0 =    2.00000    
  Output array = 
    32.00  80.00  80.00  40.00  10.00   1.00

  Option IOPT =        6
  X0 =   -2.00000    
  Output array = 
   -32.00  80.00 -80.00  40.00 -10.00   1.00

R8POLY_F2P_TEST
  R8POLY_F2P: factorial => power sum.

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  The factorial polynomial coefficients:

       1   1.00000    
       2   9.00000    
       3   15.0000    
       4   4.00000    

  The recovered power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

R8POLY_FVAL_TEST
  R8POLY_FVAL evaluates a polynomial in factorial form.

  The factorial polynomial coefficients:

       1   1.00000    
       2   2.00000    
       3   3.00000    
       4   4.00000    
       5   5.00000    

  R8POLY (   2.00000     ) =    11.0000    
  The correct value is 11.

R8POLY_N2P_TEST
  R8POLY_N2P: Newton => power sum;

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  Newton polynomial coefficients:

     49.0000    132.0000     51.0000      4.0000

  Newton polynomial abscissas:

      2.0000      4.0000      6.0000      8.0000

  The recovered power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

R8POLY_NVAL_TEST
  R8POLY_NVAL evaluates a Newton polynomial.

  Newton polynomial coefficients:

        1.0000      2.0000      3.0000      4.0000      5.0000

  Newton polynomial abscissas:

        0.0000      1.0000      2.0000      3.0000

  R8POLY (    2.00000     ) =    11.0000    
  The correct value is 11.

R8POLY_NX_TEST
  R8POLY_NX replaces one abscissa in a Newton polynomial.

  Newton polynomial coefficients:

       1   1.00000    
       2   2.00000    
       3   3.00000    

  Newton polynomial abscissas:

       1   1.00000    
       2   2.00000    
       3   3.00000    

  Replace one abscissa by X =    0.00000    

  Revised Newton polynomial coefficients:

       1   5.00000    
       2  -4.00000    
       3   3.00000    

  Revised Newton polynomial abscissas:

       1   0.00000    
       2   1.00000    
       3   2.00000    

R8POLY_P2F_TEST
  R8POLY_P2F: power sum => factorial;

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  The factorial polynomial coefficients:

       1   1.00000    
       2   9.00000    
       3   15.0000    
       4   4.00000    

  The recovered power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

R8POLY_P2N_TEST
  R8POLY_P2N: Power sum => Newton.

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  Newton polynomial coefficients:

     49.0000    132.0000     51.0000      4.0000

  Newton polynomial abscissas:

      2.0000      4.0000      6.0000      8.0000

  The recovered power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

R8POLY_P2T_TEST
  R8POLY_P2T: Power sum => Taylor.

  Taylor expansion point is X =    2.00000    

  The Taylor coefficients:

        1.0000      2.0000      3.0000      4.0000

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         -   21.0000     * x ^   2
         +   38.0000     * x
         -   23.0000    

  The recovered Taylor coefficients:

        1.0000      2.0000      3.0000      4.0000

R8POLY_PRINT_TEST
  R8POLY_PRINT prints an R8POLY.

  The polynomial:

  p(x) =     1.40000     * x ^   4
         +   3.30000     * x ^   3
         +   2.20000     * x ^   2
         +   5.10000     * x
         -   2.00000    

R8POLY_PVAL_TEST
  R8POLY_PVAL evaluates a polynomial
  in power sum form.

  The polynomial to be evaluated:

  p(x) =     5.00000     * x ^   4
         +   4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  At X =    2.00000    
  Computed polynomial value is    129.000    
  Correct value is 129.

R8POLY_T2P_TEST
  R8POLY_T2P: Taylor => Power sum;

  Taylor expansion point is X =    2.00000    

  The Taylor coefficients:

        1.0000      2.0000      3.0000      4.0000

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         -   21.0000     * x ^   2
         +   38.0000     * x
         -   23.0000    

  The recovered Taylor coefficients:

        1.0000      2.0000      3.0000      4.0000

R8VEC_BACKTRACK_TEST
  R8VEC_BACKTRACK uses backtracking, seeking a vector X
  of N values which satisfies some condition.

  In this demonstration, we have 8 integers W(I).
  We seek all subsets that sum to 53.
  X(I) is 0 or 1 if the entry is skipped or used.

   1      53.00:     15.00   22.00   16.00
   2      53.00:     15.00   14.00   16.00    8.00
   3      53.00:     22.00   14.00    9.00    8.00

  Done!

R8VEC_FRAC_TEST
  R8VEC_FRAC: K-th smallest real vector entry;

  The real array to search:

       1   2.18418    
       2   9.56318    
       3   8.29509    
       4   5.61695    
       5   4.15307    
       6  0.661187    
       7   2.57578    
       8   1.09957    
       9  0.438290    
      10   6.33966    

  Frac   R8VEC_FRAC

     1    0.438290    
     2    0.661187    
     3     1.09957    
     4     2.18418    
     5     2.57578    
     6     4.15307    
     7     5.61695    
     8     6.33966    
     9     8.29509    
    10     9.56318    

R8VEC_MIRROR_NEXT_TEST
  R8VEC_MIRROR_NEXT generates all sign variations
  of a real vector.

  Next vector:

       1   1.00000    
       2   2.00000    
       3   3.00000    

  Next vector:

       1  -1.00000    
       2   2.00000    
       3   3.00000    

  Next vector:

       1   1.00000    
       2  -2.00000    
       3   3.00000    

  Next vector:

       1  -1.00000    
       2  -2.00000    
       3   3.00000    

  Next vector:

       1   1.00000    
       2   2.00000    
       3  -3.00000    

  Next vector:

       1  -1.00000    
       2   2.00000    
       3  -3.00000    

  Next vector:

       1   1.00000    
       2  -2.00000    
       3  -3.00000    

  Next vector:

       1  -1.00000    
       2  -2.00000    
       3  -3.00000    

  Done.

  Next vector:

       1   1.00000    
       2   0.00000    
       3   3.00000    

  Next vector:

       1  -1.00000    
       2   0.00000    
       3   3.00000    

  Next vector:

       1   1.00000    
       2  -0.00000    
       3  -3.00000    

  Next vector:

       1  -1.00000    
       2  -0.00000    
       3  -3.00000    

  Done.

RAT_ADD_TEST
  RAT_ADD adds two rationals.

  A = 3/4
  B = 10/7
  C = A + B = 61/28

RAT_DIV_TEST
  RAT_DIV divides two rationals.

  A = 3/4
  B = 10/7
  C = A / B = 21/40

RAT_FAREY_TEST
  RAT_FAREY computes a row of the Farey fraction table.

  Row        1
  Number of fractions:        2

    0  1
    1  1

  Row        2
  Number of fractions:        3

    0  1  1
    1  2  1

  Row        3
  Number of fractions:        5

    0  1  1  2  1
    1  3  2  3  1

  Row        4
  Number of fractions:        7

    0  1  1  1  2  3  1
    1  4  3  2  3  4  1

  Row        5
  Number of fractions:       11

    0  1  1  1  2  1  3  2  3  4  1
    1  5  4  3  5  2  5  3  4  5  1

  Row        6
  Number of fractions:       13

    0  1  1  1  1  2  1  3  2  3  4  5  1
    1  6  5  4  3  5  2  5  3  4  5  6  1

  Row        7
  Number of fractions:       19

    0  1  1  1  1  2  1  2  3  1  4  3  2  5  3  4  5  6  1
    1  7  6  5  4  7  3  5  7  2  7  5  3  7  4  5  6  7  1

RAT_FAREY2_TEST
  RAT_FAREY2 computes a row of the Farey fraction table.

  Row        1

    0  1
    1  1

  Row        2

    0  1  1
    1  2  1

  Row        3

    0  1  1  2  1
    1  3  2  3  1

  Row        4

    0  1  1  2  1  3  2  3  1
    1  4  3  5  2  5  3  4  1

  Row        5

    0  1  1  2  1  3  2  3  1  4  3  5  2  5  3  4  1
    1  5  4  7  3  8  5  7  2  7  5  8  3  7  4  5  1

RAT_MUL_TEST
  RAT_MUL multiplies two rationals.

  A = 3/4
  B = 10/7
  C = A * B = 15/14

RAT_NORMALIZE_TEST
  RAT_NORMALIZE normalizes a rational.

           A           B             A             B
                                 normalized     normalized

           3           4             3           4
           1        1000             1        1000
          20           1            20           1
           8           4             2           1
         -10           7           -10           7
           9         -15            -3           5
         -11         -11             1           1

RAT_SUM_FORMULA_TEST
  RAT_SUM_FORMULA computes the coefficients for the
  formulas for the sums of powers of integers.

  Power Sum Coefficients:

    1    0    0    0    0    0    0


    1    1    0    0    0    0    0
    2    2

    1    1    1    0    0    0    0
    3    2    6

    1    1    1    0    0    0    0
    4    2    4

    1    1    1    0   -1    0    0
    5    2    3        30

    1    1    5    0   -1    0    0
    6    2   12        12

    1    1    1    0   -1    0    1
    7    2    2         6        42

RAT_TO_CFRAC_TEST
  RAT_TO_CFRAC fraction => continued fraction,

  Regular fraction is     4096 /    15625

  Continued fraction coefficients:

       1         0
       2         3
       3         1
       4         4
       5         2
       6         1
       7         1
       8        11
       9        13

  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.

  I, P(I), Q(I), P(I)/Q(I)

    1       0       1   0.00000    
    2       1       3  0.333333    
    3       1       4  0.250000    
    4       5      19  0.263158    
    5      11      42  0.261905    
    6      16      61  0.262295    
    7      27     103  0.262136    
    8     313    1194  0.262144    
    9    4096   15625  0.262144    

RAT_TO_DEC_TEST
  RAT_TO_DEC fraction => decimal,

  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.

  Then convert to decimal, and the equivalent real.

  Then convert back to rational and the equivalent real.

   -0.588297=        -563/         957
   -0.588297=  -588296760*10^          -9
   -0.588297=   -14707419/    25000000

    1.172598=         659/         562
    1.172598=  1172597864*10^          -9
    1.172598=   146574733/   125000000

   -2.522388=        -169/          67
   -2.522388=  -252238805*10^          -8
   -2.522388=   -50447761/    20000000

   -4.409091=        -485/         110
   -4.409091=  -440909090*10^          -8
   -4.409091=   -44090909/    10000000

   -1.440063=        -913/         634
   -1.440063= -1440063091*10^          -9
   -1.440063= -1440063091/  1000000000

   -1.948889=        -877/         450
   -1.948889= -1948888888*10^          -9
   -1.948889=  -243611111/   125000000

   -0.260927=        -197/         755
   -0.260927=  -260927152*10^          -9
   -0.260927=   -16307947/    62500000

  297.500000=         595/           2
  297.500000=        2975*10^          -1
  297.500000=         595/           2

    2.264957=         795/         351
    2.264957=   226495726*10^          -8
    2.264957=   113247863/    50000000

  -57.928571=        -811/          14
  -57.928571=  -579285714*10^          -7
  -57.928571=  -289642857/     5000000

RAT_TO_R8_TEST
  RAT_TO_R8 converts a rational to a real number.

  The maximum number of digits allowed is   4

     R   =>  A / B  =>  R2

   -0.315817   -1579      5000 -0.315800
    7.063176    8829      1250  7.063200
    5.795092   57951     10000  5.795100
    3.116954    3117      1000  3.117000
    1.653071   16531     10000  1.653100
   -1.838813   -4597      2500 -1.838800
    0.075778     379      5000  0.075800
   -1.400432   -3501      2500 -1.400400
   -2.061710  -20617     10000 -2.061700
    3.839657   38397     10000  3.839700

RAT_TO_S_TEST
  RAT_TO_S converts a rational to a string.

           A           B    A/B

           3           4      3/4
           1        1000      1/1000
          20           1      20
           8           4      8/4
         -10           7      -10/7
           9         -15      9/-15
         -11         -11      -11/-11

RAT_WIDTH_TEST
  RAT_WIDTH determines the "width" of a rational.

     Top    Bottom  Width

      1000       3       4
      1000      40       4
      1000     500       4
      1000    6000       4
      1000   70000       5
         1       1       1
        -1     200       3
       -10     200       3
      -100     200       4
     -1000     200       5
         1    -200       3
        10    -200       3
       100    -200       4
      1000    -200       5
     10000    -200       6
        17    3000       4
   4000000 4000000       7

RATMAT_DET_TEST
  RATMAT_DET: determinant of a rational matrix.


  The 123/456/789 matrix:

   1   2   3


   4   5   6


   7   8   9


  Determinant of the 123/456/789 matrix:
         0 /        1

  The Hilbert matrix:

   1   1   1
   2   3   4

   1   1   1
   3   4   5

   1   1   1
   4   5   6

  Determinant of the Hilbert matrix:
         1 /    43200

  The -1 2 -1 matrix:

   2  -1   0


  -1   2  -1


   0  -1   2


  Determinant of the -1,2,-1 matrix:
         4 /        1

RATMAT_PRINT_TEST
  RATMAT_PRINT prints a rational matrix.

  The Hilbert matrix:

   1   1   1
   2   3   4

   1   1   1
   3   4   5

   1   1   1
   4   5   6

   1   1   1
   5   6   7

REGRO_NEXT_TEST
  REGRO_NEXT generates all restricted growth 
  functions.

    1  1  1  1  1
    2  1  1  1  2
    3  1  1  2  1
    4  1  1  2  2
    5  1  1  2  3
    6  1  2  1  1
    7  1  2  1  2
    8  1  2  1  3
    9  1  2  2  1
   10  1  2  2  2
   11  1  2  2  3
   12  1  2  3  1
   13  1  2  3  2
   14  1  2  3  3
   15  1  2  3  4

RFRAC_TO_CFRAC_TEST
  RFRAC_TO_CFRAC: ratio to continued fration.

  Rational polynomial fraction coefficients:

  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000

  Continued fraction coefficients:

       1   1.00000    
       2  0.500000    
       3   1.33333    
       4 -0.500000    
       5  -1.50000    
       6   2.00000    

  Recovered rational polynomial:

  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000

RFRAC_TO_JFRAC_TEST
  RFRAC_TO_JFRAC converts a rational polynomial
  fraction to a J fraction.

  The original rational polynomial coefficients:

    0.218418      0.956318      0.829509      0.561695      0.415307    
    0.661187E-01
    0.641848      0.273997      0.109216       1.57976      0.153816    
     1.12019       1.00000    

  The J fraction coefficients:

    0.661187E-01   24.0763     -0.310636       1.40276       5.16789    
   -0.686133E-01
    -5.16104       4.91564     -0.945630      -1.04001       2.91888    
    0.432351    

  The recovered rational polynomial:

    0.218418      0.956318      0.829509      0.561695      0.415307    
    0.661187E-01
    0.641848      0.273997      0.109216       1.57976      0.153816    
     1.12019       1.00000    

SCHROEDER_TEST
  SCHROEDER computes the Schroeder numbers.

       N        S(N)

         1         1
         2         1
         3         3
         4        11
         5        45
         6       197
         7       903
         8      4279
         9     20793
        10    103049

SORT_HEAP_EXTERNAL_TEST
  SORT_HEAP_EXTERNAL sorts objects externally.

  Unsorted array:

       1         5
       2        20
       3        17
       4        12
       5         9
       6         2
       7         6
       8         3
       9         1
      10        13
      11         2
      12         9
      13         9
      14        16
      15        16
      16         1
      17        18
      18         8
      19         2
      20         1

  Sorted array:

       1         1
       2         1
       3         1
       4         2
       5         2
       6         2
       7         3
       8         5
       9         6
      10         8
      11         9
      12         9
      13         9
      14        12
      15        13
      16        16
      17        16
      18        17
      19        18
      20        20

SUBCOMP_NEXT_TEST
  SUBCOMP_NEXT generates subcompositions.

  Seek all subcompositions of N =        6
  using K =        3 parts.

     #   Sum

     1     0     0   0   0
     2     1     1   0   0
     3     1     0   1   0
     4     1     0   0   1
     5     2     2   0   0
     6     2     1   1   0
     7     2     0   2   0
     8     2     1   0   1
     9     2     0   1   1
    10     2     0   0   2
    11     3     3   0   0
    12     3     2   1   0
    13     3     1   2   0
    14     3     0   3   0
    15     3     2   0   1
    16     3     1   1   1
    17     3     0   2   1
    18     3     1   0   2
    19     3     0   1   2
    20     3     0   0   3
    21     4     4   0   0
    22     4     3   1   0
    23     4     2   2   0
    24     4     1   3   0
    25     4     0   4   0
    26     4     3   0   1
    27     4     2   1   1
    28     4     1   2   1
    29     4     0   3   1
    30     4     2   0   2
    31     4     1   1   2
    32     4     0   2   2
    33     4     1   0   3
    34     4     0   1   3
    35     4     0   0   4
    36     5     5   0   0
    37     5     4   1   0
    38     5     3   2   0
    39     5     2   3   0
    40     5     1   4   0
    41     5     0   5   0
    42     5     4   0   1
    43     5     3   1   1
    44     5     2   2   1
    45     5     1   3   1
    46     5     0   4   1
    47     5     3   0   2
    48     5     2   1   2
    49     5     1   2   2
    50     5     0   3   2
    51     5     2   0   3
    52     5     1   1   3
    53     5     0   2   3
    54     5     1   0   4
    55     5     0   1   4
    56     5     0   0   5
    57     6     6   0   0
    58     6     5   1   0
    59     6     4   2   0
    60     6     3   3   0
    61     6     2   4   0
    62     6     1   5   0
    63     6     0   6   0
    64     6     5   0   1
    65     6     4   1   1
    66     6     3   2   1
    67     6     2   3   1
    68     6     1   4   1
    69     6     0   5   1
    70     6     4   0   2
    71     6     3   1   2
    72     6     2   2   2
    73     6     1   3   2
    74     6     0   4   2
    75     6     3   0   3
    76     6     2   1   3
    77     6     1   2   3
    78     6     0   3   3
    79     6     2   0   4
    80     6     1   1   4
    81     6     0   2   4
    82     6     1   0   5
    83     6     0   1   5
    84     6     0   0   6

SUBCOMPNZ_NEXT_TEST
  SUBCOMPNZ_NEXT generates subcompositions
  using nonzero parts.

  Seek all subcompositions of N =        6
  using K =        3 nonzero parts.

     #   Sum

     1     3     1   1   1
     2     4     2   1   1
     3     4     1   2   1
     4     4     1   1   2
     5     5     3   1   1
     6     5     2   2   1
     7     5     1   3   1
     8     5     2   1   2
     9     5     1   2   2
    10     5     1   1   3
    11     6     4   1   1
    12     6     3   2   1
    13     6     2   3   1
    14     6     1   4   1
    15     6     3   1   2
    16     6     2   2   2
    17     6     1   3   2
    18     6     2   1   3
    19     6     1   2   3
    20     6     1   1   4

SUBCOMPNZ2_NEXT_TEST
  SUBCOMPNZ2_NEXT generates subcompositions
  using nonzero parts.

  Seek all subcompositions of N
  using K =        3 nonzero parts.

  N ranges from        5 to        7

     #     N

     1     5     3   1   1
     2     5     2   2   1
     3     5     1   3   1
     4     5     2   1   2
     5     5     1   2   2
     6     5     1   1   3
     7     6     4   1   1
     8     6     3   2   1
     9     6     2   3   1
    10     6     1   4   1
    11     6     3   1   2
    12     6     2   2   2
    13     6     1   3   2
    14     6     2   1   3
    15     6     1   2   3
    16     6     1   1   4
    17     7     5   1   1
    18     7     4   2   1
    19     7     3   3   1
    20     7     2   4   1
    21     7     1   5   1
    22     7     4   1   2
    23     7     3   2   2
    24     7     2   3   2
    25     7     1   4   2
    26     7     3   1   3
    27     7     2   2   3
    28     7     1   3   3
    29     7     2   1   4
    30     7     1   2   4
    31     7     1   1   5

SUBSET_BY_SIZE_NEXT_TEST
  SUBSET_BY_SIZE_NEXT generates all subsets of an N set.

     1     1 2 3 4 5
     2     1 2 3 4
     3     1 2 3 5
     4     1 2 4 5
     5     1 3 4 5
     6     2 3 4 5
     7     1 2 3
     8     1 2 4
     9     1 2 5
    10     1 3 4
    11     1 3 5
    12     1 4 5
    13     2 3 4
    14     2 3 5
    15     2 4 5
    16     3 4 5
    17     1 2
    18     1 3
    19     1 4
    20     1 5
    21     2 3
    22     2 4
    23     2 5
    24     3 4
    25     3 5
    26     4 5
    27     1
    28     2
    29     3
    30     4
    31     5
    32    The empty set

SUBSET_GRAY_NEXT_TEST
  SUBSET_GRAY_NEXT generates all subsets of an N set.
  using the Gray code ordering:
  0 0 1 0 1 means the subset contains 3 and 5.

  Gray code

     1     0 0 0 0 0
     2     1 0 0 0 0
     3     1 1 0 0 0
     4     0 1 0 0 0
     5     0 1 1 0 0
     6     1 1 1 0 0
     7     1 0 1 0 0
     8     0 0 1 0 0
     9     0 0 1 1 0
    10     1 0 1 1 0
    11     1 1 1 1 0
    12     0 1 1 1 0
    13     0 1 0 1 0
    14     1 1 0 1 0
    15     1 0 0 1 0
    16     0 0 0 1 0
    17     0 0 0 1 1
    18     1 0 0 1 1
    19     1 1 0 1 1
    20     0 1 0 1 1
    21     0 1 1 1 1
    22     1 1 1 1 1
    23     1 0 1 1 1
    24     0 0 1 1 1
    25     0 0 1 0 1
    26     1 0 1 0 1
    27     1 1 1 0 1
    28     0 1 1 0 1
    29     0 1 0 0 1
    30     1 1 0 0 1
    31     1 0 0 0 1
    32     0 0 0 0 1

SUBSET_GRAY_RANK_TEST
  SUBSET_GRAY_RANK returns rank of a subset of an N set
  using the Gray code ordering.

  For N =        5
  the subset is:
   1 0 1 1 0

  The rank is       28

SUBSET_GRAY_UNRANK_TEST
  SUBSET_GRAY_UNRANK finds the subset of an N set
  of a given rank under the Gray code ordering.

  N is        5

  Rank   Subset

     1     0 0 0 0 0
     2     0 0 0 0 1
     3     0 0 0 1 1
     4     0 0 0 1 0
     5     0 0 1 1 0
     6     0 0 1 1 1
     7     0 0 1 0 1
     8     0 0 1 0 0
     9     0 1 1 0 0
    10     0 1 1 0 1

SUBSET_LEX_NEXT_TEST
  SUBSET_LEX_NEXT generates all subsets of an N set.
  The user can impose a restriction on the
  maximum size of the subsets.

  Here, we require the subsets to be no larger
  than        3
   1
   1 2
   1 2 3
   1 2 4
   1 2 5
   1 3
   1 3 4
   1 3 5
   1 4
   1 4 5
   1 5
   2
   2 3
   2 3 4
   2 3 5
   2 4
   2 4 5
   2 5
   3
   3 4
   3 4 5
   3 5
   4
   4 5
   5
  The empty set.

SUBSET_RANDOM_TEST
  SUBSET_RANDOM picks a subset at random.
  The number of elements in the main set is        5

   0 1 1 1 0
   0 0 0 0 1
   0 0 0 1 1
   0 1 0 0 0
   1 1 0 0 0

SUBTRIANGLE_NEXT_TEST
  SUBTRIANGLE_NEXT generates the indices of subtriangles
  in a triangle whose edges were divided into N subedges.

  For this test, N =        4

  Rank    I1  J1    I2  J2    I3  J3

     1     0   0     1   0     0   1
     2     1   1     0   1     1   0
     3     1   0     2   0     1   1
     4     2   1     1   1     2   0
     5     2   0     3   0     2   1
     6     3   1     2   1     3   0
     7     3   0     4   0     3   1
     8     0   1     1   1     0   2
     9     1   2     0   2     1   1
    10     1   1     2   1     1   2
    11     2   2     1   2     2   1
    12     2   1     3   1     2   2
    13     0   2     1   2     0   3
    14     1   3     0   3     1   2
    15     1   2     2   2     1   3
    16     0   3     1   3     0   4

THUE_BINARY_NEXT_TEST
  THUE_BINARY_NEXT returns the next Thue binary sequence.

     1    0
     2    01
     4    0110
     8    01101001
    16    0110100110010110
    32    01101001100101101001011001101001
    64    0110100110010110100101100110100110010110011010010110100110010110

THUE_TERNARY_NEXT_TEST
  THUE_TERNARY_NEXT returns the next 
  Thue ternary sequence.

     1    1
     3    102
     6    102120
    12    102120102012
    24    102120102012102120121020
    48    102120102012102120121020102120102012102010212012

TRIANG_TEST
  TRIANG relabels elements for a partial ordering,

  The input matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        1      0      0      0      0      0      0      0      0      0
       2        0      1      0      1      0      1      0      1      0      0
       3        1      0      1      1      0      0      0      0      0      0
       4        0      0      0      1      0      0      0      0      0      0
       5        1      1      1      1      1      1      1      1      0      1
       6        0      0      0      1      0      1      0      1      0      0
       7        1      0      1      1      0      1      1      1      0      1
       8        0      0      0      1      0      0      0      1      0      0
       9        0      0      0      0      0      0      0      0      0      0
      10        1      0      1      1      0      0      0      1      0      1

  The new ordering:

     1   2   3   4   5   6   7   8   9  10
     5   6   4   9   1   7   2   8  10   3

  The reordered matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        1      1      1      1      1      1      1      1      1      0
       2        0      1      1      1      1      0      1      1      1      0
       3        0      0      1      1      1      0      0      1      1      0
       4        0      0      0      1      1      0      0      0      1      0
       5        0      0      0      0      1      0      0      0      0      0
       6        0      0      0      0      0      1      1      1      1      0
       7        0      0      0      0      0      0      1      1      1      0
       8        0      0      0      0      0      0      0      1      1      0
       9        0      0      0      0      0      0      0      0      1      0
      10        0      0      0      0      0      0      0      0      0      0

TUPLE_NEXT_TEST
  TUPLE_NEXT returns the next "tuple", that is,
  a vector of N integers, each between M1 and M2.

  M1 =        2
  M2 =        4
  N =         2

     1    2  2
     2    2  3
     3    2  4
     4    3  2
     5    3  3
     6    3  4
     7    4  2
     8    4  3
     9    4  4

TUPLE_NEXT_FAST_TEST
  TUPLE_NEXT_FAST returns the next "tuple", that is,
  a vector of N integers, each between 1 and M.

  M =        3
  N =        2

     0    1  1
     1    1  2
     2    1  3
     3    2  1
     4    2  2
     5    2  3
     6    3  1
     7    3  2
     8    3  3

TUPLE_NEXT_GE_TEST
  TUPLE_NEXT_GE returns the next "tuple", that is,
  a vector of N integers, each between 1 and M,
  with the constraint that the entries be
  nondecreasing.

  M =        3
  N =        3

     1    1  1  1
     2    1  1  2
     3    1  1  3
     4    1  2  2
     5    1  2  3
     6    1  3  3
     7    2  2  2
     8    2  2  3
     9    2  3  3
    10    3  3  3

TUPLE_NEXT2_TEST
  TUPLE_NEXT2 returns the next "tuple", that is,
  a vector of N integers.

  N =        3

  The minimum tuple is 
         2       3       8
  The maximum tuple is 
         4       3       5

     1    2  3  8
     2    2  3  7
     3    2  3  6
     4    2  3  5
     5    3  3  8
     6    3  3  7
     7    3  3  6
     8    3  3  5
     9    4  3  8
    10    4  3  7
    11    4  3  6
    12    4  3  5

UBVEC_ADD_TEST
  UBVEC_ADD adds unsigned binary vectors
  representing unsigned integers;

        I        J        K = I + J


        22        96
  Directly:                118
  UBVEC_ADD                118

        83        56
  Directly:                139
  UBVEC_ADD                139

        41         6
  Directly:                 47
  UBVEC_ADD                 47

        26        11
  Directly:                 37
  UBVEC_ADD                 37

         4        64
  Directly:                 68
  UBVEC_ADD                 68

         6        45
  Directly:                 51
  UBVEC_ADD                 51

        40        76
  Directly:                116
  UBVEC_ADD                116

        80         0
  Directly:                 80
  UBVEC_ADD                 80

        90        35
  Directly:                125
  UBVEC_ADD                125

         9         1
  Directly:                 10
  UBVEC_ADD                 10

UBVEC_PRINT_TEST
  UBVEC_PRINT prints an unsigned binary vector.

  UBVEC:
  1001011100

UBVEC_TO_UI4_TEST
  UBVEC_TO_UI4 converts an unsigned binary vector
  to an unsigned integer;

  I --> BVEC  -->  I

    0  0000000000    0
    1  0000000001    1
    2  0000000010    2
    3  0000000011    3
    4  0000000100    4
    5  0000000101    5
    6  0000000110    6
    7  0000000111    7
    8  0000001000    8
    9  0000001001    9
   10  0000001010   10

UBVEC_XOR_TEST
  UBVEC_XOR computes the exclusive OR of two
  unsigned binary vectors representing unsigned integers;

        I        J        K = I XOR J

        22        96       118
        83        56       107
        41         6        47
        26        11        17
         4        64        68
         6        45        43
        40        76       100
        80         0        80
        90        35       121
         9         1         8

UI4_TO_UBVEC_TEST
  UI4_TO_UBVEC converts an unsigned integer to an 
  unsigned binary vector;

  I --> BVEC  -->  I

    0  0000000000    0
    1  0000000001    1
    2  0000000010    2
    3  0000000011    3
    4  0000000100    4
    5  0000000101    5
    6  0000000110    6
    7  0000000111    7
    8  0000001000    8
    9  0000001001    9
   10  0000001010   10

VEC_COLEX_NEXT_TEST
  VEC_COLEX_NEXT generates all DIM_NUM-vectors
  in colex order in a given base BASE.

  The dimension DIM_NUM =        3
  The base BASE =                3

     0   0   0
     1   0   0
     2   0   0
     0   1   0
     1   1   0
     2   1   0
     0   2   0
     1   2   0
     2   2   0
     0   0   1
     1   0   1
     2   0   1
     0   1   1
     1   1   1
     2   1   1
     0   2   1
     1   2   1
     2   2   1
     0   0   2
     1   0   2
     2   0   2
     0   1   2
     1   1   2
     2   1   2
     0   2   2
     1   2   2
     2   2   2

VEC_COLEX_NEXT2_TEST
  VEC_COLEX_NEXT2 generates all DIM_NUM-vectors
  in colex order in given bases BASE(1:DIM_NUM).

  The dimension DIM_NUM =        3

  The base vector:

     2   1   3

     0   0   0
     1   0   0
     0   0   1
     1   0   1
     0   0   2
     1   0   2

VEC_COLEX_NEXT3_TEST
  VEC_COLEX_NEXT3 generates all DIM_NUM-vectors
  in colex order in given bases BASE(1:DIM_NUM).

  The dimension DIM_NUM =        3

  The base vector:

     2   1   3

     1   1   1
     2   1   1
     1   1   2
     2   1   2
     1   1   3
     2   1   3

VEC_GRAY_NEXT_TEST
  VEC_GRAY_NEXT generates product space elements.

  The number of components is        4
  The number of elements is       16
  Each component has its own number of degrees of
  freedom.

  Rank Change        2   2   1   4

     1     1         0   0   0   0
     2     4         0   0   0   1
     3     4         0   0   0   2
     4     4         0   0   0   3
     5     2         0   1   0   3
     6     4         0   1   0   2
     7     4         0   1   0   1
     8     4         0   1   0   0
     9     1         1   1   0   0
    10     4         1   1   0   1
    11     4         1   1   0   2
    12     4         1   1   0   3
    13     2         1   0   0   3
    14     4         1   0   0   2
    15     4         1   0   0   1
    16     4         1   0   0   0

VEC_GRAY_RANK_TEST
  VEC_GRAY_RANK ranks product space elements.
  VEC_GRAY_UNRANK unranks them.

  The number of components is        4
  The number of elements is       16
  Each component has its own number of degrees of
  freedom, which, for this example, are:

  Rank Change        2   2   1   4


  VEC_GRAY_RANK reports the element 

          1   1   0   2

  has rank       11

VEC_GRAY_UNRANK_TEST
  VEC_GRAY_UNRANK unranks product space elements.

  The number of components is        4
  The number of elements is       16
  Each component has its own number of degrees of
  freedom, which, for this example, are:

  Rank Change        2   2   1   4


  VEC_GRAY_UNRANK reports the element of rank        7
  is:

          0   1   0   1


VEC_LEX_NEXT_TEST
  VEC_LEX_NEXT generates all N-vectors
  in a given base.  Here we use base        3

     0   0   0
     0   0   1
     0   0   2
     0   1   0
     0   1   1
     0   1   2
     0   2   0
     0   2   1
     0   2   2
     1   0   0
     1   0   1
     1   0   2
     1   1   0
     1   1   1
     1   1   2
     1   2   0
     1   2   1
     1   2   2
     2   0   0
     2   0   1
     2   0   2
     2   1   0
     2   1   1
     2   1   2
     2   2   0
     2   2   1
     2   2   2

VEC_RANDOM_TEST
  VEC_RANDOM generates a random N-vector
  in a given base.
  Here, we use base        3

     0   2   2
     1   1   0
     0   0   0
     1   0   1
     1   2   2

VECTOR_CONSTRAINED_NEXT_TEST
  VECTOR_CONSTRAINED_NEXT:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( (X(1:N)-1) * P / X_MAX(1:N) ) <= P

  X_MIN:   2   2   1
  X_MAX:   4   5   3

  Maximum allowed CONSTRAINT = P =           60

         1            27         2         2         1
         2            42         3         2         1
         3            57         4         2         1
         4            39         2         3         1
         5            54         3         3         1
         6            51         2         4         1
         7            47         2         2         2
         8            59         2         3         2

VECTOR_CONSTRAINED_NEXT2_TEST
  VECTOR_CONSTRAINED_NEXT2:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( X(1:N) * P / X_MAX(1:N) ) <= P

  X_MIN:   1   1
  X_MAX:   5   6

  Maximum allowed CONSTRAINT = P =           30

         1            11         1         1
         2            17         2         1
         3            23         3         1
         4            29         4         1
         5            16         1         2
         6            22         2         2
         7            28         3         2
         8            21         1         3
         9            27         2         3
        10            26         1         4

  X_MIN:   1   1   1
  X_MAX:   5   6   4

  Maximum allowed CONSTRAINT = P =          120

         1            74         1         1         1
         2            98         2         1         1
         3            94         1         2         1
         4           118         2         2         1
         5           114         1         3         1
         6           104         1         1         2

VECTOR_CONSTRAINED_NEXT3_TEST
  VECTOR_CONSTRAINED_NEXT3:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    CONSTRAINT = sum ( X(1:N) / X_MAX(1:N) )
  Accept only vectors for which:
    CONSTRAINT <= 1

  X_MIN:   1   1
  X_MAX:   5   6

         1    0.366667             1         1
         2    0.566667             2         1
         3    0.766667             3         1
         4    0.966667             4         1
         5    0.533333             1         2
         6    0.733333             2         2
         7    0.933333             3         2
         8    0.700000             1         3
         9    0.900000             2         3
        10    0.866667             1         4

  X_MIN:   1   1   1
  X_MAX:   5   6   4

         1    0.616667             1         1         1
         2    0.816667             2         1         1
         3    0.783333             1         2         1
         4    0.983333             2         2         1
         5    0.950000             1         3         1
         6    0.866667             1         1         2

VECTOR_CONSTRAINED_NEXT4_TEST
  VECTOR_CONSTRAINED_NEXT4:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    TOTAL <= Q

  ALPHA:   4.00000       3.00000    
  Q:       20.0000    
  X_MIN:   1   0
  X_MAX:   2   6

         1     4.00000             1         0
         2     8.00000             2         0
         3     7.00000             1         1
         4     11.0000             2         1
         5     10.0000             1         2
         6     14.0000             2         2
         7     13.0000             1         3
         8     17.0000             2         3
         9     16.0000             1         4
        10     20.0000             2         4
        11     19.0000             1         5

  ALPHA:   4.00000       3.00000       5.00000    
  Q:       20.0000    
  X_MIN:   1   0   1
  X_MAX:   2   6   4

         1     9.00000             1         0         1
         2     13.0000             2         0         1
         3     12.0000             1         1         1
         4     16.0000             2         1         1
         5     15.0000             1         2         1
         6     19.0000             2         2         1
         7     18.0000             1         3         1
         8     14.0000             1         0         2
         9     18.0000             2         0         2
        10     17.0000             1         1         2
        11     20.0000             1         2         2
        12     19.0000             1         0         3

VECTOR_CONSTRAINED_NEXT5_TEST
  VECTOR_CONSTRAINED_NEXT5:
  Generate integer vectors X such that:
    SUM_MIN <= sum ( X(1:N) ) <= SUM_MAX,
  We require every X(I) to be at least 1.

  N =              3
  SUM_MIN =        5
  SUM_MAX =        7

         #        X(1)      X(2)      X(3)

         1         3         1         1
         2         2         2         1
         3         2         1         2
         4         1         3         1
         5         1         2         2
         6         1         1         3
         7         4         1         1
         8         3         2         1
         9         3         1         2
        10         2         3         1
        11         2         2         2
        12         2         1         3
        13         1         4         1
        14         1         3         2
        15         1         2         3
        16         1         1         4
        17         5         1         1
        18         4         2         1
        19         4         1         2
        20         3         3         1
        21         3         2         2
        22         3         1         3
        23         2         4         1
        24         2         3         2
        25         2         2         3
        26         2         1         4
        27         1         5         1
        28         1         4         2
        29         1         3         3
        30         1         2         4
        31         1         1         5

VECTOR_CONSTRAINED_NEXT6_TEST
  VECTOR_CONSTRAINED_NEXT6:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX

  ALPHA:   4.00000       3.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MIN:   1   0
  X_MAX:   2   6

         1     16.0000             1         4
         2     19.0000             1         5
         3     17.0000             2         3
         4     20.0000             2         4

  ALPHA:   4.00000       3.00000       5.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MIN:   1   0   1
  X_MAX:   2   6   4

         1     19.0000             1         0         3
         2     17.0000             1         1         2
         3     20.0000             1         2         2
         4     18.0000             1         3         1
         5     18.0000             2         0         2
         6     16.0000             2         1         1
         7     19.0000             2         2         1

VECTOR_CONSTRAINED_NEXT7_TEST
  VECTOR_CONSTRAINED_NEXT7:
  Consider vectors:
    0 <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX

  ALPHA:   4.00000       3.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MAX:   2   6

         1     18.0000             0         6
         2     19.0000             1         5
         3     17.0000             2         3
         4     20.0000             2         4

  ALPHA:   4.00000       3.00000       5.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MAX:   2   6   4

         1     20.0000             0         0         4
         2     18.0000             0         1         3
         3     19.0000             0         3         2
         4     17.0000             0         4         1
         5     20.0000             0         5         1
         6     18.0000             0         6         0
         7     19.0000             1         0         3
         8     17.0000             1         1         2
         9     20.0000             1         2         2
        10     18.0000             1         3         1
        11     19.0000             1         5         0
        12     18.0000             2         0         2
        13     19.0000             2         2         1
        14     17.0000             2         3         0
        15     20.0000             2         4         0

VECTOR_NEXT_TEST
  VECTOR_NEXT:
  Generate all vectors X such that:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),

  XMIN           1         4
     1           1         4
     2           2         4
     3           1         5
     4           2         5
     5           1         6
     6           2         6
  XMAX           2         6

  XMIN           1         4         3
     1           1         4         3
     2           2         4         3
     3           1         5         3
     4           2         5         3
     5           1         6         3
     6           2         6         3
     7           1         4         4
     8           2         4         4
     9           1         5         4
    10           2         5         4
    11           1         6         4
    12           2         6         4
  XMAX           2         6         4

YTB_ENUM_TEST
  YTB_ENUM counts Young table.

  N    YTB(N)

           0         0
           1         1
           2         2
           3         4
           4        10
           5        26
           6        76
           7       232
           8       764
           9      2620
          10      9496

YTB_NEXT_TEST
  YTB_NEXT generates Young tables.


   1   4   6
   2   5
   3

   1   3   6
   2   5
   4

   1   2   6
   3   5
   4

   1   3   6
   2   4
   5

   1   2   6
   3   4
   5

   1   4   5
   2   6
   3

   1   3   5
   2   6
   4

   1   2   5
   3   6
   4

   1   3   4
   2   6
   5

   1   2   4
   3   6
   5

   1   2   3
   4   6
   5

   1   3   5
   2   4
   6

   1   2   5
   3   4
   6

   1   3   4
   2   5
   6

   1   2   4
   3   5
   6

   1   2   3
   4   5
   6

YTB_RANDOM_TEST
  YTB_RANDOM generates a random Young table

   1   2   6
   3   5
   4

   1   3   6
   2   4
   5

   1   3   6
   2   4
   5

   1   3   5
   2   4
   6

   1   2   5
   3   4
   6

SUBSET_TEST
  Normal end of execution.

22 January 2020   1:20:56.189 PM
